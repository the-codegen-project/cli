---
sidebar_position: 5
sidebar_label: Contributing
---
# Contributing to The Codegen Project

<!-- toc is generated with GitHub Actions do not remove toc markers -->

<!-- toc -->

- [Acceptance criteria and process](#acceptance-criteria-and-process)
  * [Fixing bugs](#fixing-bugs)
  * [New features](#new-features)
- [Repository Architecture](#repository-architecture)
- [Getting started](#getting-started)
- [Contribution recogniton](#contribution-recogniton)
- [Summary of the contribution flow](#summary-of-the-contribution-flow)
- [Code of Conduct](#code-of-conduct)
- [Our Development Process](#our-development-process)
- [Pull Requests](#pull-requests)
- [Conventional commits](#conventional-commits)

<!-- tocstop -->

First of all, thank you 🙇🏾‍♀️ for considering contributing to The Codegen Project

If you have any questions, are unsure how your use-case fits in, or want something clarified, don't hesitate to reach out, we are always happy to help out!

## Acceptance criteria and process

Even though we love contributions, we need to maintain a certain standard of what can be merged into the codebase. 

The below sections provide information about our acceptance criteria, based on the type of contribution you make.

### Fixing bugs 

The Acceptance Criteria for _fixing any bug_ means that you should be able to reproduce the error using tests that will fail, unless a fix is implemented.

### New features

The Acceptance Criteria for _adding new features_ requires a few things in order to be accepted. This ensures all features are well described and implemented before being released.

1. **Not all feature requests from the community (or maintainers!) are accepted:** Even though you are welcome to create a new feature without an issue, it might be rejected and turn out to be a waste of your time. We don't want that to happen, so make sure to create an issue first and wait to see if it's accepted after community discussion of the proposal.
1. **When creating tests for your new feature, aim for as high coverage numbers as possible:** When you run the tests (`npm run test`), you should see a `./coverage/lcov-report/index.html` file being generated. Use this to see in depth where your tests are not covering your implementation.
1. **No documentation, no feature:** If a user cannot understand a new feature, that feature basically doesn't exist! Remember to make sure that any and all relevant [documentation](./) is consistently updated.
    - New features such as new generators or inputs, etc, need associated use case documentation along side [examples](../examples).

## Repository Architecture

The repository is setup with multiple functions to keep it simple.
- `src`; includes the CLI and library code both exposed through the same package.
- `website`; is... Well the website.
- `scripts`; includes helpfull scripts for the release flow such as for building JSON Schema files from the code for configuration validation and CLI release configurations
- `test`; include all the testing done for the repository
    - `blackbox`; is a quick and dirt syntax testing of different configurations against different inputs to quickly detect problems
    - `runtime`; is sematic testing of the generated code in the corresponding languages they generate for, ensuring correct behaviour at runtime
    - The rest normal unit and integration testing of the actual CLI and library
- `examples`; is the showcase of actual projects using the CLI to simplify the implementation phase of software development.
- `schemas`; is the autogenerated JSON schemas for validating configurations.

## Getting started

Here is a quick litle get started quick tutorial;

1. Fork the repository
2. Create a branch from the upstream repository
3. Install the dependencies `npm install`
4. Make sure test pass `npm run test`
5. Adapt the source code as well as test and documentation
6. Push the changes
7. Create a PR with the proposed change
8. Get the change reviewed and merged :tada:

Happy contributing :heart:

## Contribution recogniton

We use [All Contributors](https://allcontributors.org/docs/en/specification) specification to handle recognitions.

## Summary of the contribution flow

The following is a summary of the ideal contribution flow. Please, note that Pull Requests can also be rejected by the maintainers when appropriate.

```
    ┌───────────────────────┐
    │                       │
    │    Open an issue      │
    │  (a bug report or a   │
    │   feature request)    │
    │                       │
    └───────────────────────┘
               ⇩
    ┌───────────────────────┐
    │                       │
    │  Open a Pull Request  │
    │   (only after issue   │
    │     is approved)      │
    │                       │
    └───────────────────────┘
               ⇩
    ┌───────────────────────┐
    │                       │
    │   Your changes will   │
    │     be merged and     │
    │ published on the next │
    │        release        │
    │                       │
    └───────────────────────┘
```

## Code of Conduct
We have adopted a Code of Conduct that we expect project participants to adhere to. Please [read the full text](../CODE_OF_CONDUCT.md) so that you can understand what sort of behaviour is expected.

## Our Development Process
We use Github to host code, to track issues and feature requests, as well as accept pull requests.

## Pull Requests

**Please, make sure you open an issue before starting with a Pull Request, unless it's a typo or a really obvious error.** Pull requests are the best way to propose changes to the specification. 

## Conventional commits

Our repositories follow [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/#summary) specification. Releasing to GitHub and NPM is done with the support of [semantic-release](https://semantic-release.gitbook.io/semantic-release/).

Pull requests should have a title that follows the specification, otherwise, merging is blocked. If you are not familiar with the specification simply ask maintainers to modify. You can also use this cheatsheet if you want:

- `fix: ` prefix in the title indicates that PR is a bug fix and PATCH release must be triggered.
- `feat: ` prefix in the title indicates that PR is a feature and MINOR release must be triggered.
- `docs: ` prefix in the title indicates that PR is only related to the documentation and there is no need to trigger release.
- `chore: ` prefix in the title indicates that PR is only related to cleanup in the project and there is no need to trigger release.
- `test: ` prefix in the title indicates that PR is only related to tests and there is no need to trigger release.
- `refactor: ` prefix in the title indicates that PR is only related to refactoring and there is no need to trigger release.

What about MAJOR release? just add `!` to the prefix, like `fix!: ` or `refactor!: `

Prefix that follows specification is not enough though. Remember that the title must be clear and descriptive with usage of [imperative mood](https://chris.beams.io/posts/git-commit/#imperative).




























