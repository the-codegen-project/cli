/* eslint-disable security/detect-object-injection */
import {
  TypeScriptFileGenerator,
  OutputModel,
  ConstrainedObjectModel
} from '@asyncapi/modelina';
import {GenericCodegenContext, PayloadRenderType} from '../../types';
import {AsyncAPIDocumentInterface} from '@asyncapi/parser';
import {
  processAsyncAPIPayloads,
  ProcessedPayloadSchemaData
} from '../../inputs/asyncapi/generators/payloads';
import {processOpenAPIPayloads} from '../../inputs/openapi/generators/payloads';
import {z} from 'zod';
import {defaultCodegenTypescriptModelinaOptions} from './utils';
import {OpenAPIV2, OpenAPIV3, OpenAPIV3_1} from 'openapi-types';
import {TS_COMMON_PRESET} from '@asyncapi/modelina';
import {
  createValidationPreset,
  createUnionPreset
} from '../../modelina/presets';

export const zodTypeScriptPayloadGenerator = z.object({
  id: z.string().optional().default('payloads-typescript'),
  dependencies: z.array(z.string()).optional().default([]),
  preset: z.literal('payloads').default('payloads'),
  outputPath: z.string().optional().default('src/__gen__/payloads'),
  serializationType: z.literal('json').optional().default('json'),
  language: z.literal('typescript').optional().default('typescript'),
  enum: z
    .enum(['enum', 'union'])
    .optional()
    .default('enum')
    .describe(
      'By default all payloads enum types are generated as separate enum types, but in some cases a simple union type might be more prudent.'
    ),
  map: z
    .enum(['indexedObject', 'map', 'record'])
    .optional()
    .default('record')
    .describe('Which map type to use when a dictionary type is needed'),
  useForJavaScript: z
    .boolean()
    .optional()
    .default(true)
    .describe(
      'By default we assume that the models might be transpiled to JS, therefore JS restrictions will be applied by default.'
    ),
  includeValidation: z
    .boolean()
    .optional()
    .default(true)
    .describe(
      'By default we assume that the models will be used to also validate incoming data.'
    ),
  rawPropertyNames: z
    .boolean()
    .optional()
    .default(false)
    .describe(
      'Use raw property names instead of constrained ones, where you most likely need to access them with obj["propertyName"] instead of obj.propertyName'
    )
});

export type TypeScriptPayloadGenerator = z.input<
  typeof zodTypeScriptPayloadGenerator
>;

export type TypeScriptPayloadGeneratorInternal = z.infer<
  typeof zodTypeScriptPayloadGenerator
>;

export const defaultTypeScriptPayloadGenerator: TypeScriptPayloadGeneratorInternal =
  zodTypeScriptPayloadGenerator.parse({});

export interface TypeScriptPayloadContext extends GenericCodegenContext {
  inputType: 'asyncapi' | 'openapi';
  asyncapiDocument?: AsyncAPIDocumentInterface;
  openapiDocument?:
    | OpenAPIV3.Document
    | OpenAPIV2.Document
    | OpenAPIV3_1.Document;
  generator: TypeScriptPayloadGeneratorInternal;
}

export type TypeScriptPayloadRenderType =
  PayloadRenderType<TypeScriptPayloadGeneratorInternal>;

// Interface for processed payloads data (input-agnostic)
export interface ProcessedPayloadData {
  channelModels: Record<
    string,
    {messageModel: OutputModel; messageType: string}
  >;
  operationModels: Record<
    string,
    {messageModel: OutputModel; messageType: string}
  >;
  otherModels: Array<{messageModel: OutputModel; messageType: string}>;
}

// Core generator function that works with processed data
export async function generateTypescriptPayloadsCore(
  processedData: ProcessedPayloadData,
  generator: TypeScriptPayloadGeneratorInternal
): Promise<TypeScriptPayloadRenderType> {
  // The models are already generated by the input processors,
  // so we just need to return them in the expected format
  return {
    channelModels: processedData.channelModels,
    operationModels: processedData.operationModels,
    otherModels: processedData.otherModels,
    generator
  };
}

// Core generator function that works with processed schema data
// eslint-disable-next-line sonarjs/cognitive-complexity
export async function generateTypescriptPayloadsCoreFromSchemas({
  context,
  processedSchemaData
}: {
  processedSchemaData: ProcessedPayloadSchemaData;
  context: TypeScriptPayloadContext;
}): Promise<TypeScriptPayloadRenderType> {
  const generator = context.generator;
  const modelinaGenerator = new TypeScriptFileGenerator({
    ...defaultCodegenTypescriptModelinaOptions,
    presets: [
      {
        preset: TS_COMMON_PRESET,
        options: {
          marshalling: true
        }
      },
      createValidationPreset(
        {
          includeValidation: generator.includeValidation
        },
        context
      ),
      createUnionPreset(
        {
          includeValidation: generator.includeValidation
        },
        context
      )
    ],
    enumType: generator.enum,
    mapType: generator.map,
    rawPropertyNames: generator.rawPropertyNames,
    useJavascriptReservedKeywords: generator.useForJavaScript
  });

  const channelModels: Record<
    string,
    {messageModel: OutputModel; messageType: string}
  > = {};
  const operationModels: Record<
    string,
    {messageModel: OutputModel; messageType: string}
  > = {};
  const otherModels: Array<{messageModel: OutputModel; messageType: string}> =
    [];

  // Generate models for channel payloads
  for (const [channelId, schemaData] of Object.entries(
    processedSchemaData.channelPayloads
  )) {
    if (schemaData) {
      const models = await modelinaGenerator.generateToFiles(
        schemaData.schema,
        generator.outputPath,
        {exportType: 'named'},
        true
      );
      if (models.length > 0) {
        //Use first model as the root message model
        const messageModel = models[0].model;
        let messageType = messageModel.type;
        if (!(messageModel instanceof ConstrainedObjectModel)) {
          messageType = messageModel.name;
        }
        channelModels[channelId] = {
          messageModel: models[0],
          messageType
        };

        // Add any additional models to otherModels
        for (let i = 1; i < models.length; i++) {
          const additionalModel = models[i].model;
          otherModels.push({
            messageModel: models[i],
            messageType: additionalModel.type
          });
        }
      }
    }
  }

  // Generate models for operation payloads
  for (const [operationId, schemaData] of Object.entries(
    processedSchemaData.operationPayloads
  )) {
    if (schemaData) {
      const models = await modelinaGenerator.generateToFiles(
        schemaData.schema,
        generator.outputPath,
        {exportType: 'named'},
        true
      );
      if (models.length > 0) {
        //Use first model as the root message model
        const messageModel = models[0].model;
        let messageType = messageModel.type;
        if (!(messageModel instanceof ConstrainedObjectModel)) {
          messageType = messageModel.name;
        }
        operationModels[operationId] = {
          messageModel: models[0],
          messageType
        };

        // Add any additional models to otherModels
        for (let i = 1; i < models.length; i++) {
          const additionalModel = models[i].model;
          otherModels.push({
            messageModel: models[i],
            messageType: additionalModel.type
          });
        }
      }
    }
  }

  // Generate models for other payloads
  for (const schemaData of processedSchemaData.otherPayloads) {
    const models = await modelinaGenerator.generateToFiles(
      schemaData.schema,
      generator.outputPath,
      {exportType: 'named'},
      true
    );
    for (const model of models) {
      const messageModel = model.model;
      let messageType = messageModel.type;
      if (!(messageModel instanceof ConstrainedObjectModel)) {
        messageType = messageModel.name;
      }
      otherModels.push({
        messageModel: model,
        messageType
      });
    }
  }

  return {
    channelModels,
    operationModels,
    otherModels,
    generator
  };
}

// Main generator function that orchestrates input processing and generation
export async function generateTypescriptPayload(
  context: TypeScriptPayloadContext
): Promise<TypeScriptPayloadRenderType> {
  const {asyncapiDocument, openapiDocument, inputType} = context;

  let processedSchemaData: ProcessedPayloadSchemaData;

  // Process input based on type
  switch (inputType) {
    case 'asyncapi': {
      if (!asyncapiDocument) {
        throw new Error('Expected AsyncAPI input, was not given');
      }

      processedSchemaData = await processAsyncAPIPayloads(asyncapiDocument);
      break;
    }
    case 'openapi': {
      if (!openapiDocument) {
        throw new Error('Expected OpenAPI input, was not given');
      }

      processedSchemaData = processOpenAPIPayloads(openapiDocument);
      break;
    }
    default:
      throw new Error(`Unsupported input type: ${inputType}`);
  }

  // Generate final result using processed schema data
  return generateTypescriptPayloadsCoreFromSchemas({
    processedSchemaData,
    context
  });
}
