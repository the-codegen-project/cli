// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`channels typescript OpenAPI input should generate HTTP client protocol code for OpenAPI spec: openapi-http_client-index 1`] = `
"import * as http_client from './http_client';

export {http_client};
"
`;

exports[`channels typescript OpenAPI input should generate HTTP client protocol code for OpenAPI spec: openapi-http_client-protocol-code 1`] = `
"import {Pet} from './../../../../../payloads/Pet';
import {FindPetsByStatusAndCategoryParameters} from './../../../../../parameters/FindPetsByStatusAndCategoryParameters';
import { URLSearchParams, URL } from 'url';
import * as NodeFetch from 'node-fetch';

// ============================================================================
// Common Types - Shared across all HTTP client functions
// ============================================================================

/**
 * Standard HTTP response interface that wraps fetch-like responses
 */
export interface HttpResponse {
  ok: boolean;
  status: number;
  statusText: string;
  headers?: Headers | Record<string, string>;
  json: () => Record<any, any> | Promise<Record<any, any>>;
}

/**
 * Pagination info extracted from response
 */
export interface PaginationInfo {
  /** Total number of items (if available from headers like X-Total-Count) */
  totalCount?: number;
  /** Total number of pages (if available) */
  totalPages?: number;
  /** Current page/offset */
  currentOffset?: number;
  /** Items per page */
  limit?: number;
  /** Next cursor (for cursor-based pagination) */
  nextCursor?: string;
  /** Previous cursor */
  prevCursor?: string;
  /** Whether there are more items */
  hasMore?: boolean;
}

/**
 * Rich response wrapper returned by HTTP client functions
 */
export interface HttpClientResponse<T> {
  /** The deserialized response payload */
  data: T;
  /** HTTP status code */
  status: number;
  /** HTTP status text */
  statusText: string;
  /** Response headers */
  headers: Record<string, string>;
  /** Raw JSON response before deserialization */
  rawData: Record<string, any>;
  /** Pagination info extracted from response (if applicable) */
  pagination?: PaginationInfo;
  /** Fetch the next page (if pagination is configured and more data exists) */
  getNextPage?: () => Promise<HttpClientResponse<T>>;
  /** Fetch the previous page (if pagination is configured) */
  getPrevPage?: () => Promise<HttpClientResponse<T>>;
  /** Check if there's a next page */
  hasNextPage?: () => boolean;
  /** Check if there's a previous page */
  hasPrevPage?: () => boolean;
}

/**
 * HTTP request parameters passed to the request hook
 */
export interface HttpRequestParams {
  url: string;
  headers?: Record<string, string | string[]>;
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
  credentials?: RequestCredentials;
  body?: any;
}

/**
 * Token response structure for OAuth2 flows
 */
export interface TokenResponse {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
}

// ============================================================================
// Security Configuration Types - Grouped for better autocomplete
// ============================================================================

/**
 * Bearer token authentication configuration
 */
export interface BearerAuth {
  type: 'bearer';
  token: string;
}

/**
 * Basic authentication configuration (username/password)
 */
export interface BasicAuth {
  type: 'basic';
  username: string;
  password: string;
}

/**
 * API key authentication configuration
 */
export interface ApiKeyAuth {
  type: 'apiKey';
  key: string;
  name?: string;        // Name of the API key parameter (default: 'X-API-Key')
  in?: 'header' | 'query'; // Where to place the API key (default: 'header')
}

/**
 * OAuth2 authentication configuration
 *
 * Supports server-side flows only:
 * - client_credentials: Server-to-server authentication
 * - password: Resource owner password credentials (legacy, not recommended)
 * - Pre-obtained accessToken: For tokens obtained via browser-based flows
 *
 * For browser-based flows (implicit, authorization_code), obtain the token
 * separately and pass it as accessToken.
 */
export interface OAuth2Auth {
  type: 'oauth2';
  /** Pre-obtained access token (required if not using a server-side flow) */
  accessToken?: string;
  /** Refresh token for automatic token renewal on 401 */
  refreshToken?: string;
  /** Token endpoint URL (required for client_credentials/password flows and token refresh) */
  tokenUrl?: string;
  /** Client ID (required for flows and token refresh) */
  clientId?: string;
  /** Client secret (optional, depends on OAuth provider) */
  clientSecret?: string;
  /** Requested scopes */
  scopes?: string[];
  /** Server-side flow type */
  flow?: 'password' | 'client_credentials';
  /** Username for password flow */
  username?: string;
  /** Password for password flow */
  password?: string;
  /** Callback when tokens are refreshed (for caching/persistence) */
  onTokenRefresh?: (newTokens: TokenResponse) => void;
}

/**
 * Union type for all authentication methods - provides autocomplete support
 */
export type AuthConfig = BearerAuth | BasicAuth | ApiKeyAuth | OAuth2Auth;

// ============================================================================
// Pagination Types
// ============================================================================

/**
 * Where to place pagination parameters
 */
export type PaginationLocation = 'query' | 'header';

/**
 * Offset-based pagination configuration
 */
export interface OffsetPagination {
  type: 'offset';
  in?: PaginationLocation;  // Where to place params (default: 'query')
  offset: number;
  limit: number;
  offsetParam?: string;  // Param name for offset (default: 'offset' for query, 'X-Offset' for header)
  limitParam?: string;   // Param name for limit (default: 'limit' for query, 'X-Limit' for header)
}

/**
 * Cursor-based pagination configuration
 */
export interface CursorPagination {
  type: 'cursor';
  in?: PaginationLocation;  // Where to place params (default: 'query')
  cursor?: string;
  limit?: number;
  cursorParam?: string;  // Param name for cursor (default: 'cursor' for query, 'X-Cursor' for header)
  limitParam?: string;   // Param name for limit (default: 'limit' for query, 'X-Limit' for header)
}

/**
 * Page-based pagination configuration
 */
export interface PagePagination {
  type: 'page';
  in?: PaginationLocation;  // Where to place params (default: 'query')
  page: number;
  pageSize: number;
  pageParam?: string;     // Param name for page (default: 'page' for query, 'X-Page' for header)
  pageSizeParam?: string; // Param name for page size (default: 'pageSize' for query, 'X-Page-Size' for header)
}

/**
 * Range-based pagination (typically used with headers)
 * Follows RFC 7233 style: Range: items=0-24
 */
export interface RangePagination {
  type: 'range';
  in?: 'header';  // Range pagination is typically header-only
  start: number;
  end: number;
  unit?: string;        // Range unit (default: 'items')
  rangeHeader?: string; // Header name (default: 'Range')
}

/**
 * Union type for all pagination methods
 */
export type PaginationConfig = OffsetPagination | CursorPagination | PagePagination | RangePagination;

// ============================================================================
// Retry Configuration
// ============================================================================

/**
 * Retry policy configuration for failed requests
 */
export interface RetryConfig {
  maxRetries?: number;           // Maximum number of retry attempts (default: 3)
  initialDelayMs?: number;       // Initial delay before first retry (default: 1000)
  maxDelayMs?: number;           // Maximum delay between retries (default: 30000)
  backoffMultiplier?: number;    // Multiplier for exponential backoff (default: 2)
  retryableStatusCodes?: number[]; // Status codes to retry (default: [408, 429, 500, 502, 503, 504])
  retryOnNetworkError?: boolean; // Retry on network errors (default: true)
  onRetry?: (attempt: number, delay: number, error: Error) => void; // Callback on each retry
}

// ============================================================================
// Hooks Configuration - Extensible callback system
// ============================================================================

/**
 * Hooks for customizing HTTP client behavior
 */
export interface HttpHooks {
  /**
   * Called before each request to transform/modify the request parameters
   * Return modified params or undefined to use original
   */
  beforeRequest?: (params: HttpRequestParams) => HttpRequestParams | Promise<HttpRequestParams>;

  /**
   * The actual request implementation - allows swapping fetch for axios, etc.
   * Default: uses node-fetch
   */
  makeRequest?: (params: HttpRequestParams) => Promise<HttpResponse>;

  /**
   * Called after each response for logging, metrics, etc.
   * Can transform the response before it's processed
   */
  afterResponse?: (response: HttpResponse, params: HttpRequestParams) => HttpResponse | Promise<HttpResponse>;

  /**
   * Called on request error for logging, error transformation, etc.
   */
  onError?: (error: Error, params: HttpRequestParams) => Error | Promise<Error>;
}

// ============================================================================
// Common Request Context
// ============================================================================

/**
 * Base context shared by all HTTP client functions
 */
export interface HttpClientContext {
  server?: string;
  path?: string;

  // Authentication - grouped for better autocomplete
  auth?: AuthConfig;

  // Pagination configuration
  pagination?: PaginationConfig;

  // Retry configuration
  retry?: RetryConfig;

  // Hooks for extensibility
  hooks?: HttpHooks;

  // Additional options
  additionalHeaders?: Record<string, string | string[]>;

  // Query parameters
  queryParams?: Record<string, string | number | boolean | undefined>;
}

// ============================================================================
// Helper Functions - Shared logic extracted for reuse
// ============================================================================

/**
 * Default retry configuration
 */
const DEFAULT_RETRY_CONFIG: Required<RetryConfig> = {
  maxRetries: 3,
  initialDelayMs: 1000,
  maxDelayMs: 30000,
  backoffMultiplier: 2,
  retryableStatusCodes: [408, 429, 500, 502, 503, 504],
  retryOnNetworkError: true,
  onRetry: () => {},
};

/**
 * Default request hook implementation using node-fetch
 */
const defaultMakeRequest = async (params: HttpRequestParams): Promise<HttpResponse> => {
  return NodeFetch.default(params.url, {
    body: params.body,
    method: params.method,
    headers: params.headers
  }) as unknown as HttpResponse;
};

/**
 * Apply authentication to headers and URL based on auth config
 */
function applyAuth(
  auth: AuthConfig | undefined,
  headers: Record<string, string | string[]>,
  url: string
): { headers: Record<string, string | string[]>; url: string } {
  if (!auth) return { headers, url };

  switch (auth.type) {
    case 'bearer':
      headers['Authorization'] = \`Bearer \${auth.token}\`;
      break;

    case 'basic': {
      const credentials = Buffer.from(\`\${auth.username}:\${auth.password}\`).toString('base64');
      headers['Authorization'] = \`Basic \${credentials}\`;
      break;
    }

    case 'apiKey': {
      const keyName = auth.name ?? 'X-API-Key';
      const keyIn = auth.in ?? 'header';

      if (keyIn === 'header') {
        headers[keyName] = auth.key;
      } else {
        const separator = url.includes('?') ? '&' : '?';
        url = \`\${url}\${separator}\${keyName}=\${encodeURIComponent(auth.key)}\`;
      }
      break;
    }

    case 'oauth2': {
      // If we have an access token, use it directly
      // Token flows (client_credentials, password) are handled separately
      if (auth.accessToken) {
        headers['Authorization'] = \`Bearer \${auth.accessToken}\`;
      }
      break;
    }
  }

  return { headers, url };
}

/**
 * Validate OAuth2 configuration based on flow type
 */
function validateOAuth2Config(auth: OAuth2Auth): void {
  // If using a flow, validate required fields
  switch (auth.flow) {
    case 'client_credentials':
      if (!auth.tokenUrl) throw new Error('OAuth2 Client Credentials flow requires tokenUrl');
      if (!auth.clientId) throw new Error('OAuth2 Client Credentials flow requires clientId');
      break;

    case 'password':
      if (!auth.tokenUrl) throw new Error('OAuth2 Password flow requires tokenUrl');
      if (!auth.clientId) throw new Error('OAuth2 Password flow requires clientId');
      if (!auth.username) throw new Error('OAuth2 Password flow requires username');
      if (!auth.password) throw new Error('OAuth2 Password flow requires password');
      break;

    default:
      // No flow specified - must have accessToken for OAuth2 to work
      if (!auth.accessToken && !auth.flow) {
        // This is fine - token refresh can still work if refreshToken is provided
        // Or the request will just be made without auth
      }
      break;
  }
}

/**
 * Apply pagination parameters to URL and/or headers based on configuration
 */
function applyPagination(
  pagination: PaginationConfig | undefined,
  url: string,
  headers: Record<string, string | string[]>
): { url: string; headers: Record<string, string | string[]> } {
  if (!pagination) return { url, headers };

  const location = pagination.in ?? 'query';
  const isHeader = location === 'header';

  // Helper to get default param names based on location
  const getDefaultName = (queryName: string, headerName: string) =>
    isHeader ? headerName : queryName;

  const queryParams = new URLSearchParams();
  const headerParams: Record<string, string> = {};

  const addParam = (name: string, value: string) => {
    if (isHeader) {
      headerParams[name] = value;
    } else {
      queryParams.append(name, value);
    }
  };

  switch (pagination.type) {
    case 'offset':
      addParam(
        pagination.offsetParam ?? getDefaultName('offset', 'X-Offset'),
        String(pagination.offset)
      );
      addParam(
        pagination.limitParam ?? getDefaultName('limit', 'X-Limit'),
        String(pagination.limit)
      );
      break;

    case 'cursor':
      if (pagination.cursor) {
        addParam(
          pagination.cursorParam ?? getDefaultName('cursor', 'X-Cursor'),
          pagination.cursor
        );
      }
      if (pagination.limit !== undefined) {
        addParam(
          pagination.limitParam ?? getDefaultName('limit', 'X-Limit'),
          String(pagination.limit)
        );
      }
      break;

    case 'page':
      addParam(
        pagination.pageParam ?? getDefaultName('page', 'X-Page'),
        String(pagination.page)
      );
      addParam(
        pagination.pageSizeParam ?? getDefaultName('pageSize', 'X-Page-Size'),
        String(pagination.pageSize)
      );
      break;

    case 'range': {
      // Range pagination is always header-based (RFC 7233 style)
      const unit = pagination.unit ?? 'items';
      const headerName = pagination.rangeHeader ?? 'Range';
      headerParams[headerName] = \`\${unit}=\${pagination.start}-\${pagination.end}\`;
      break;
    }
  }

  // Apply query params to URL
  const queryString = queryParams.toString();
  if (queryString) {
    const separator = url.includes('?') ? '&' : '?';
    url = \`\${url}\${separator}\${queryString}\`;
  }

  // Merge header params
  const updatedHeaders = { ...headers, ...headerParams };

  return { url, headers: updatedHeaders };
}

/**
 * Apply query parameters to URL
 */
function applyQueryParams(queryParams: Record<string, string | number | boolean | undefined> | undefined, url: string): string {
  if (!queryParams) return url;

  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(queryParams)) {
    if (value !== undefined) {
      params.append(key, String(value));
    }
  }

  const paramString = params.toString();
  if (!paramString) return url;

  const separator = url.includes('?') ? '&' : '?';
  return \`\${url}\${separator}\${paramString}\`;
}

/**
 * Sleep for a specified number of milliseconds
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Calculate delay for exponential backoff
 */
function calculateBackoffDelay(
  attempt: number,
  config: Required<RetryConfig>
): number {
  const delay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attempt - 1);
  return Math.min(delay, config.maxDelayMs);
}

/**
 * Determine if a request should be retried based on error/response
 */
function shouldRetry(
  error: Error | null,
  response: HttpResponse | null,
  config: Required<RetryConfig>,
  attempt: number
): boolean {
  if (attempt >= config.maxRetries) return false;

  if (error && config.retryOnNetworkError) return true;

  if (response && config.retryableStatusCodes.includes(response.status)) return true;

  return false;
}

/**
 * Execute request with retry logic
 */
async function executeWithRetry(
  params: HttpRequestParams,
  makeRequest: (params: HttpRequestParams) => Promise<HttpResponse>,
  retryConfig?: RetryConfig
): Promise<HttpResponse> {
  const config = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };
  let lastError: Error | null = null;
  let lastResponse: HttpResponse | null = null;

  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        const delay = calculateBackoffDelay(attempt, config);
        config.onRetry(attempt, delay, lastError ?? new Error('Retry attempt'));
        await sleep(delay);
      }

      const response = await makeRequest(params);

      // Check if we should retry this response
      if (!shouldRetry(null, response, config, attempt + 1)) {
        return response;
      }

      lastResponse = response;
      lastError = new Error(\`HTTP Error: \${response.status} \${response.statusText}\`);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (!shouldRetry(lastError, null, config, attempt + 1)) {
        throw lastError;
      }
    }
  }

  // All retries exhausted
  if (lastResponse) {
    return lastResponse;
  }
  throw lastError ?? new Error('Request failed after retries');
}

/**
 * Handle OAuth2 token flows (client_credentials, password)
 */
async function handleOAuth2TokenFlow(
  auth: OAuth2Auth,
  originalParams: HttpRequestParams,
  makeRequest: (params: HttpRequestParams) => Promise<HttpResponse>,
  retryConfig?: RetryConfig
): Promise<HttpResponse | null> {
  if (!auth.flow || !auth.tokenUrl) return null;

  const params = new URLSearchParams();

  if (auth.flow === 'client_credentials') {
    params.append('grant_type', 'client_credentials');
    params.append('client_id', auth.clientId!);
  } else if (auth.flow === 'password') {
    params.append('grant_type', 'password');
    params.append('username', auth.username || '');
    params.append('password', auth.password || '');
    params.append('client_id', auth.clientId!);
  } else {
    return null;
  }

  if (auth.clientSecret) {
    params.append('client_secret', auth.clientSecret);
  }
  if (auth.scopes && auth.scopes.length > 0) {
    params.append('scope', auth.scopes.join(' '));
  }

  const authHeaders: Record<string, string> = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  // Use basic auth for client credentials if both client ID and secret are provided
  if (auth.flow === 'client_credentials' && auth.clientId && auth.clientSecret) {
    const credentials = Buffer.from(\`\${auth.clientId}:\${auth.clientSecret}\`).toString('base64');
    authHeaders['Authorization'] = \`Basic \${credentials}\`;
    params.delete('client_id');
    params.delete('client_secret');
  }

  const tokenResponse = await NodeFetch.default(auth.tokenUrl, {
    method: 'POST',
    headers: authHeaders,
    body: params.toString()
  });

  if (!tokenResponse.ok) {
    throw new Error(\`OAuth2 token request failed: \${tokenResponse.statusText}\`);
  }

  const tokenData = await tokenResponse.json();
  const tokens: TokenResponse = {
    accessToken: tokenData.access_token,
    refreshToken: tokenData.refresh_token,
    expiresIn: tokenData.expires_in
  };

  // Notify the client about the tokens
  if (auth.onTokenRefresh) {
    auth.onTokenRefresh(tokens);
  }

  // Retry the original request with the new token
  const updatedHeaders = { ...originalParams.headers };
  updatedHeaders['Authorization'] = \`Bearer \${tokens.accessToken}\`;

  return executeWithRetry({ ...originalParams, headers: updatedHeaders }, makeRequest, retryConfig);
}

/**
 * Handle OAuth2 token refresh on 401 response
 */
async function handleTokenRefresh(
  auth: OAuth2Auth,
  originalParams: HttpRequestParams,
  makeRequest: (params: HttpRequestParams) => Promise<HttpResponse>,
  retryConfig?: RetryConfig
): Promise<HttpResponse | null> {
  if (!auth.refreshToken || !auth.tokenUrl || !auth.clientId) return null;

  const refreshResponse = await NodeFetch.default(auth.tokenUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: auth.refreshToken,
      client_id: auth.clientId,
      ...(auth.clientSecret ? { client_secret: auth.clientSecret } : {})
    }).toString()
  });

  if (!refreshResponse.ok) {
    throw new Error('Unauthorized');
  }

  const tokenData = await refreshResponse.json();
  const newTokens: TokenResponse = {
    accessToken: tokenData.access_token,
    refreshToken: tokenData.refresh_token || auth.refreshToken,
    expiresIn: tokenData.expires_in
  };

  // Notify the client about the refreshed tokens
  if (auth.onTokenRefresh) {
    auth.onTokenRefresh(newTokens);
  }

  // Retry the original request with the new token
  const updatedHeaders = { ...originalParams.headers };
  updatedHeaders['Authorization'] = \`Bearer \${newTokens.accessToken}\`;

  return executeWithRetry({ ...originalParams, headers: updatedHeaders }, makeRequest, retryConfig);
}

/**
 * Handle HTTP error status codes with standardized messages
 */
function handleHttpError(status: number, statusText: string): never {
  switch (status) {
    case 401:
      throw new Error('Unauthorized');
    case 403:
      throw new Error('Forbidden');
    case 404:
      throw new Error('Not Found');
    case 500:
      throw new Error('Internal Server Error');
    default:
      throw new Error(\`HTTP Error: \${status} \${statusText}\`);
  }
}

/**
 * Extract headers from response into a plain object
 */
function extractHeaders(response: HttpResponse): Record<string, string> {
  const headers: Record<string, string> = {};

  if (response.headers) {
    if (typeof (response.headers as any).forEach === 'function') {
      // Headers object (fetch API)
      (response.headers as Headers).forEach((value, key) => {
        headers[key.toLowerCase()] = value;
      });
    } else {
      // Plain object
      for (const [key, value] of Object.entries(response.headers)) {
        headers[key.toLowerCase()] = value;
      }
    }
  }

  return headers;
}

/**
 * Extract pagination info from response headers
 */
function extractPaginationInfo(
  headers: Record<string, string>,
  currentPagination?: PaginationConfig
): PaginationInfo | undefined {
  const info: PaginationInfo = {};
  let hasPaginationInfo = false;

  // Common total count headers
  const totalCount = headers['x-total-count'] || headers['x-total'] || headers['total-count'];
  if (totalCount) {
    info.totalCount = parseInt(totalCount, 10);
    hasPaginationInfo = true;
  }

  // Total pages
  const totalPages = headers['x-total-pages'] || headers['x-page-count'];
  if (totalPages) {
    info.totalPages = parseInt(totalPages, 10);
    hasPaginationInfo = true;
  }

  // Next cursor
  const nextCursor = headers['x-next-cursor'] || headers['x-cursor-next'];
  if (nextCursor) {
    info.nextCursor = nextCursor;
    info.hasMore = true;
    hasPaginationInfo = true;
  }

  // Previous cursor
  const prevCursor = headers['x-prev-cursor'] || headers['x-cursor-prev'];
  if (prevCursor) {
    info.prevCursor = prevCursor;
    hasPaginationInfo = true;
  }

  // Has more indicator
  const hasMore = headers['x-has-more'] || headers['x-has-next'];
  if (hasMore) {
    info.hasMore = hasMore.toLowerCase() === 'true' || hasMore === '1';
    hasPaginationInfo = true;
  }

  // Parse Link header (RFC 5988)
  const linkHeader = headers['link'];
  if (linkHeader) {
    const links = parseLinkHeader(linkHeader);
    if (links.next) {
      info.hasMore = true;
      hasPaginationInfo = true;
    }
  }

  // Include current pagination state
  if (currentPagination) {
    switch (currentPagination.type) {
      case 'offset':
        info.currentOffset = currentPagination.offset;
        info.limit = currentPagination.limit;
        break;
      case 'cursor':
        info.limit = currentPagination.limit;
        break;
      case 'page':
        info.currentOffset = (currentPagination.page - 1) * currentPagination.pageSize;
        info.limit = currentPagination.pageSize;
        break;
      case 'range':
        info.currentOffset = currentPagination.start;
        info.limit = currentPagination.end - currentPagination.start + 1;
        break;
    }
    hasPaginationInfo = true;
  }

  // Calculate hasMore based on total count
  if (info.hasMore === undefined && info.totalCount !== undefined &&
      info.currentOffset !== undefined && info.limit !== undefined) {
    info.hasMore = info.currentOffset + info.limit < info.totalCount;
  }

  return hasPaginationInfo ? info : undefined;
}

/**
 * Parse RFC 5988 Link header
 */
function parseLinkHeader(header: string): Record<string, string> {
  const links: Record<string, string> = {};
  const parts = header.split(',');

  for (const part of parts) {
    const match = part.match(/<([^>]+)>;\\s*rel="?([^";\\s]+)"?/);
    if (match) {
      links[match[2]] = match[1];
    }
  }

  return links;
}

/**
 * Create pagination helper functions for the response
 */
function createPaginationHelpers<T, TContext extends HttpClientContext>(
  currentConfig: TContext,
  paginationInfo: PaginationInfo | undefined,
  requestFn: (config: TContext) => Promise<HttpClientResponse<T>>
): Pick<HttpClientResponse<T>, 'getNextPage' | 'getPrevPage' | 'hasNextPage' | 'hasPrevPage'> {
  const helpers: Pick<HttpClientResponse<T>, 'getNextPage' | 'getPrevPage' | 'hasNextPage' | 'hasPrevPage'> = {};

  if (!currentConfig.pagination) {
    return helpers;
  }

  const pagination = currentConfig.pagination;

  helpers.hasNextPage = () => {
    if (paginationInfo?.hasMore !== undefined) return paginationInfo.hasMore;
    if (paginationInfo?.nextCursor) return true;
    if (paginationInfo?.totalCount !== undefined &&
        paginationInfo.currentOffset !== undefined &&
        paginationInfo.limit !== undefined) {
      return paginationInfo.currentOffset + paginationInfo.limit < paginationInfo.totalCount;
    }
    return false;
  };

  helpers.hasPrevPage = () => {
    if (paginationInfo?.prevCursor) return true;
    if (paginationInfo?.currentOffset !== undefined) {
      return paginationInfo.currentOffset > 0;
    }
    return false;
  };

  helpers.getNextPage = async () => {
    let nextPagination: PaginationConfig;

    switch (pagination.type) {
      case 'offset':
        nextPagination = { ...pagination, offset: pagination.offset + pagination.limit };
        break;
      case 'cursor':
        if (!paginationInfo?.nextCursor) throw new Error('No next cursor available');
        nextPagination = { ...pagination, cursor: paginationInfo.nextCursor };
        break;
      case 'page':
        nextPagination = { ...pagination, page: pagination.page + 1 };
        break;
      case 'range':
        const rangeSize = pagination.end - pagination.start + 1;
        nextPagination = { ...pagination, start: pagination.end + 1, end: pagination.end + rangeSize };
        break;
      default:
        throw new Error('Unsupported pagination type');
    }

    return requestFn({ ...currentConfig, pagination: nextPagination });
  };

  helpers.getPrevPage = async () => {
    let prevPagination: PaginationConfig;

    switch (pagination.type) {
      case 'offset':
        prevPagination = { ...pagination, offset: Math.max(0, pagination.offset - pagination.limit) };
        break;
      case 'cursor':
        if (!paginationInfo?.prevCursor) throw new Error('No previous cursor available');
        prevPagination = { ...pagination, cursor: paginationInfo.prevCursor };
        break;
      case 'page':
        prevPagination = { ...pagination, page: Math.max(1, pagination.page - 1) };
        break;
      case 'range':
        const size = pagination.end - pagination.start + 1;
        const newStart = Math.max(0, pagination.start - size);
        prevPagination = { ...pagination, start: newStart, end: newStart + size - 1 };
        break;
      default:
        throw new Error('Unsupported pagination type');
    }

    return requestFn({ ...currentConfig, pagination: prevPagination });
  };

  return helpers;
}

/**
 * Builds a URL with path parameters replaced
 * @param server - Base server URL
 * @param pathTemplate - Path template with {param} placeholders
 * @param parameters - Parameter object with getChannelWithParameters method
 */
function buildUrlWithParameters<T extends { getChannelWithParameters: (path: string) => string }>(
  server: string,
  pathTemplate: string,
  parameters: T
): string {
  const path = parameters.getChannelWithParameters(pathTemplate);
  return \`\${server}\${path}\`;
}

/**
 * Extracts headers from a typed headers object and merges with additional headers
 */
function applyTypedHeaders(
  typedHeaders: { marshal: () => string } | undefined,
  additionalHeaders: Record<string, string | string[]> | undefined
): Record<string, string | string[]> {
  const headers: Record<string, string | string[]> = {
    'Content-Type': 'application/json',
    ...additionalHeaders
  };

  if (typedHeaders) {
    // Parse the marshalled headers and merge them
    const marshalledHeaders = JSON.parse(typedHeaders.marshal());
    for (const [key, value] of Object.entries(marshalledHeaders)) {
      headers[key] = value as string;
    }
  }

  return headers;
}

// ============================================================================
// Generated HTTP Client Functions
// ============================================================================

export interface PostAddPetContext extends HttpClientContext {
  payload: Pet;
  requestHeaders?: { marshal: () => string };
}

async function postAddPet(context: PostAddPetContext): Promise<HttpClientResponse<Pet>> {
  // Apply defaults
  const config = {
    path: '/pet',
    server: 'localhost:3000',
    ...context,
  };

  // Validate OAuth2 config if present
  if (config.auth?.type === 'oauth2') {
    validateOAuth2Config(config.auth);
  }

  // Build headers
  let headers = context.requestHeaders
    ? applyTypedHeaders(context.requestHeaders, config.additionalHeaders)
    : { 'Content-Type': 'application/json', ...config.additionalHeaders } as Record<string, string | string[]>;

  // Build URL
  let url = \`\${config.server}\${config.path}\`;
  url = applyQueryParams(config.queryParams, url);

  // Apply pagination (can affect URL and/or headers)
  const paginationResult = applyPagination(config.pagination, url, headers);
  url = paginationResult.url;
  headers = paginationResult.headers;

  // Apply authentication
  const authResult = applyAuth(config.auth, headers, url);
  headers = authResult.headers;
  url = authResult.url;

  // Prepare body
  const body = context.payload?.marshal();

  // Determine request function
  const makeRequest = config.hooks?.makeRequest ?? defaultMakeRequest;

  // Build request params
  let requestParams: HttpRequestParams = {
    url,
    method: 'POST',
    headers,
    body
  };

  // Apply beforeRequest hook
  if (config.hooks?.beforeRequest) {
    requestParams = await config.hooks.beforeRequest(requestParams);
  }

  try {
    // Execute request with retry logic
    let response = await executeWithRetry(requestParams, makeRequest, config.retry);

    // Apply afterResponse hook
    if (config.hooks?.afterResponse) {
      response = await config.hooks.afterResponse(response, requestParams);
    }

    // Handle OAuth2 token flows that require getting a token first
    if (config.auth?.type === 'oauth2' && !config.auth.accessToken) {
      const tokenFlowResponse = await handleOAuth2TokenFlow(config.auth, requestParams, makeRequest, config.retry);
      if (tokenFlowResponse) {
        response = tokenFlowResponse;
      }
    }

    // Handle 401 with token refresh
    if (response.status === 401 && config.auth?.type === 'oauth2') {
      try {
        const refreshResponse = await handleTokenRefresh(config.auth, requestParams, makeRequest, config.retry);
        if (refreshResponse) {
          response = refreshResponse;
        }
      } catch {
        throw new Error('Unauthorized');
      }
    }

    // Handle error responses
    if (!response.ok) {
      handleHttpError(response.status, response.statusText);
    }

    // Parse response
    const rawData = await response.json();
    const responseData = Pet.unmarshal(rawData);

    // Extract response metadata
    const responseHeaders = extractHeaders(response);
    const paginationInfo = extractPaginationInfo(responseHeaders, config.pagination);

    // Build response wrapper with pagination helpers
    const result: HttpClientResponse<Pet> = {
      data: responseData,
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
      rawData,
      pagination: paginationInfo,
      ...createPaginationHelpers(config, paginationInfo, postAddPet),
    };

    return result;

  } catch (error) {
    // Apply onError hook if present
    if (config.hooks?.onError && error instanceof Error) {
      throw await config.hooks.onError(error, requestParams);
    }
    throw error;
  }
}

export interface PutUpdatePetContext extends HttpClientContext {
  payload: Pet;
  requestHeaders?: { marshal: () => string };
}

async function putUpdatePet(context: PutUpdatePetContext): Promise<HttpClientResponse<Pet>> {
  // Apply defaults
  const config = {
    path: '/pet',
    server: 'localhost:3000',
    ...context,
  };

  // Validate OAuth2 config if present
  if (config.auth?.type === 'oauth2') {
    validateOAuth2Config(config.auth);
  }

  // Build headers
  let headers = context.requestHeaders
    ? applyTypedHeaders(context.requestHeaders, config.additionalHeaders)
    : { 'Content-Type': 'application/json', ...config.additionalHeaders } as Record<string, string | string[]>;

  // Build URL
  let url = \`\${config.server}\${config.path}\`;
  url = applyQueryParams(config.queryParams, url);

  // Apply pagination (can affect URL and/or headers)
  const paginationResult = applyPagination(config.pagination, url, headers);
  url = paginationResult.url;
  headers = paginationResult.headers;

  // Apply authentication
  const authResult = applyAuth(config.auth, headers, url);
  headers = authResult.headers;
  url = authResult.url;

  // Prepare body
  const body = context.payload?.marshal();

  // Determine request function
  const makeRequest = config.hooks?.makeRequest ?? defaultMakeRequest;

  // Build request params
  let requestParams: HttpRequestParams = {
    url,
    method: 'PUT',
    headers,
    body
  };

  // Apply beforeRequest hook
  if (config.hooks?.beforeRequest) {
    requestParams = await config.hooks.beforeRequest(requestParams);
  }

  try {
    // Execute request with retry logic
    let response = await executeWithRetry(requestParams, makeRequest, config.retry);

    // Apply afterResponse hook
    if (config.hooks?.afterResponse) {
      response = await config.hooks.afterResponse(response, requestParams);
    }

    // Handle OAuth2 token flows that require getting a token first
    if (config.auth?.type === 'oauth2' && !config.auth.accessToken) {
      const tokenFlowResponse = await handleOAuth2TokenFlow(config.auth, requestParams, makeRequest, config.retry);
      if (tokenFlowResponse) {
        response = tokenFlowResponse;
      }
    }

    // Handle 401 with token refresh
    if (response.status === 401 && config.auth?.type === 'oauth2') {
      try {
        const refreshResponse = await handleTokenRefresh(config.auth, requestParams, makeRequest, config.retry);
        if (refreshResponse) {
          response = refreshResponse;
        }
      } catch {
        throw new Error('Unauthorized');
      }
    }

    // Handle error responses
    if (!response.ok) {
      handleHttpError(response.status, response.statusText);
    }

    // Parse response
    const rawData = await response.json();
    const responseData = Pet.unmarshal(rawData);

    // Extract response metadata
    const responseHeaders = extractHeaders(response);
    const paginationInfo = extractPaginationInfo(responseHeaders, config.pagination);

    // Build response wrapper with pagination helpers
    const result: HttpClientResponse<Pet> = {
      data: responseData,
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
      rawData,
      pagination: paginationInfo,
      ...createPaginationHelpers(config, paginationInfo, putUpdatePet),
    };

    return result;

  } catch (error) {
    // Apply onError hook if present
    if (config.hooks?.onError && error instanceof Error) {
      throw await config.hooks.onError(error, requestParams);
    }
    throw error;
  }
}

export interface GetFindPetsByStatusAndCategoryContext extends HttpClientContext {
  parameters: { getChannelWithParameters: (path: string) => string };
  requestHeaders?: { marshal: () => string };
}

async function getFindPetsByStatusAndCategory(context: GetFindPetsByStatusAndCategoryContext): Promise<HttpClientResponse<Pet[]>> {
  // Apply defaults
  const config = {
    path: '/pet/findByStatus/{status}/{categoryId}',
    server: 'localhost:3000',
    ...context,
  };

  // Validate OAuth2 config if present
  if (config.auth?.type === 'oauth2') {
    validateOAuth2Config(config.auth);
  }

  // Build headers
  let headers = context.requestHeaders
    ? applyTypedHeaders(context.requestHeaders, config.additionalHeaders)
    : { 'Content-Type': 'application/json', ...config.additionalHeaders } as Record<string, string | string[]>;

  // Build URL
  let url = buildUrlWithParameters(config.server, '/pet/findByStatus/{status}/{categoryId}', context.parameters);
  url = applyQueryParams(config.queryParams, url);

  // Apply pagination (can affect URL and/or headers)
  const paginationResult = applyPagination(config.pagination, url, headers);
  url = paginationResult.url;
  headers = paginationResult.headers;

  // Apply authentication
  const authResult = applyAuth(config.auth, headers, url);
  headers = authResult.headers;
  url = authResult.url;

  // Prepare body
  const body = undefined;

  // Determine request function
  const makeRequest = config.hooks?.makeRequest ?? defaultMakeRequest;

  // Build request params
  let requestParams: HttpRequestParams = {
    url,
    method: 'GET',
    headers,
    body
  };

  // Apply beforeRequest hook
  if (config.hooks?.beforeRequest) {
    requestParams = await config.hooks.beforeRequest(requestParams);
  }

  try {
    // Execute request with retry logic
    let response = await executeWithRetry(requestParams, makeRequest, config.retry);

    // Apply afterResponse hook
    if (config.hooks?.afterResponse) {
      response = await config.hooks.afterResponse(response, requestParams);
    }

    // Handle OAuth2 token flows that require getting a token first
    if (config.auth?.type === 'oauth2' && !config.auth.accessToken) {
      const tokenFlowResponse = await handleOAuth2TokenFlow(config.auth, requestParams, makeRequest, config.retry);
      if (tokenFlowResponse) {
        response = tokenFlowResponse;
      }
    }

    // Handle 401 with token refresh
    if (response.status === 401 && config.auth?.type === 'oauth2') {
      try {
        const refreshResponse = await handleTokenRefresh(config.auth, requestParams, makeRequest, config.retry);
        if (refreshResponse) {
          response = refreshResponse;
        }
      } catch {
        throw new Error('Unauthorized');
      }
    }

    // Handle error responses
    if (!response.ok) {
      handleHttpError(response.status, response.statusText);
    }

    // Parse response
    const rawData = await response.json();
    const responseData = Pet[].unmarshal(rawData);

    // Extract response metadata
    const responseHeaders = extractHeaders(response);
    const paginationInfo = extractPaginationInfo(responseHeaders, config.pagination);

    // Build response wrapper with pagination helpers
    const result: HttpClientResponse<Pet[]> = {
      data: responseData,
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
      rawData,
      pagination: paginationInfo,
      ...createPaginationHelpers(config, paginationInfo, getFindPetsByStatusAndCategory),
    };

    return result;

  } catch (error) {
    // Apply onError hook if present
    if (config.hooks?.onError && error instanceof Error) {
      throw await config.hooks.onError(error, requestParams);
    }
    throw error;
  }
}

export { postAddPet, putUpdatePet, getFindPetsByStatusAndCategory };
"
`;

exports[`channels typescript protocol-specific code generation should generate AMQP protocol code with parameters and headers: amqp-index 1`] = `
"import * as amqp from './amqp';

export {amqp};
"
`;

exports[`channels typescript protocol-specific code generation should generate AMQP protocol code with parameters and headers: amqp-protocol-code 1`] = `
"import * as TestPayloadModelModule from './../../../../../payloads/TestPayloadModel';
import {TestParameter} from './../../../../../parameters/TestParameter';
import {TestHeaders} from './../../../../../headers/TestHeaders';
import * as Amqp from 'amqplib';

/**
 * AMQP publish operation for exchange \`user/signedup/{my_parameter}/{enum_parameter}\`
 *
  * @param message to publish
 * @param parameters for topic substitution
 * @param headers optional headers to include with the message
 * @param amqp the AMQP connection to send over
 * @param options for the AMQP publish exchange operation
 */
function publishToUserSignedupExchange({
  message, 
  parameters, 
  headers, 
  amqp, 
  options
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  parameters: Parameter, 
  headers?: Headers, 
  amqp: Amqp.Connection, 
  options?: {exchange: string | undefined} & Amqp.Options.Publish
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    const exchange = options?.exchange ?? 'undefined';
    if(!exchange) {
      return reject('No exchange value found, please provide one')
    }
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
const channel = await amqp.createChannel();
const routingKey = parameters.getChannelWithParameters('user/signedup/{my_parameter}/{enum_parameter}');
// Set up message properties (headers) if provided
let publishOptions = { ...options };
if (headers) {
  const headerData = headers.marshal();
  const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
  publishOptions.headers = {};
  for (const [key, value] of Object.entries(parsedHeaders)) {
    if (value !== undefined) {
      publishOptions.headers[key] = value;
    }
  }
}
channel.publish(exchange, routingKey, Buffer.from(dataToSend), publishOptions);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * AMQP publish operation for queue \`user/signedup/{my_parameter}/{enum_parameter}\`
 *
  * @param message to publish
 * @param parameters for topic substitution
 * @param headers optional headers to include with the message
 * @param amqp the AMQP connection to send over
 * @param options for the AMQP publish queue operation
 */
function publishToUserSignedupQueue({
  message, 
  parameters, 
  headers, 
  amqp, 
  options
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  parameters: Parameter, 
  headers?: Headers, 
  amqp: Amqp.Connection, 
  options?: Amqp.Options.Publish
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
const channel = await amqp.createChannel();
const queue = parameters.getChannelWithParameters('user/signedup/{my_parameter}/{enum_parameter}');
// Set up message properties (headers) if provided
let publishOptions = { ...options };
if (headers) {
  const headerData = headers.marshal();
  const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
  publishOptions.headers = {};
  for (const [key, value] of Object.entries(parsedHeaders)) {
    if (value !== undefined) {
      publishOptions.headers[key] = value;
    }
  }
}
channel.sendToQueue(queue, Buffer.from(dataToSend), publishOptions);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * AMQP subscribe operation for queue \`user/signedup/{my_parameter}/{enum_parameter}\`
 *
  * @param {subscribeToUserSignedupQueueCallback} onDataCallback to call when messages are received
 * @param parameters for topic substitution
 * @param amqp the AMQP connection to receive from
 * @param options for the AMQP subscribe queue operation
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToUserSignedupQueue({
  onDataCallback, 
  parameters, 
  amqp, 
  options, 
  skipMessageValidation = false
}: {
  onDataCallback: (params: {err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, headers?: Headers, amqpMsg?: Amqp.ConsumeMessage}) => void, 
  parameters: Parameter, 
  amqp: Amqp.Connection, 
  options?: Amqp.Options.Consume, 
  skipMessageValidation?: boolean
}): Promise<Amqp.Channel> {
  return new Promise(async (resolve, reject) => {
    try {
      const channel = await amqp.createChannel();
const queue = parameters.getChannelWithParameters('user/signedup/{my_parameter}/{enum_parameter}');
await channel.assertQueue(queue, { durable: true });

channel.consume(queue, (msg) => {
  if (msg !== null) {
    const receivedData = msg.content.toString()
    // Extract headers if present
    let extractedHeaders: Headers | undefined = undefined;
    if (msg.properties && msg.properties.headers) {
      const headerObj: Record<string, any> = {};
      for (const [key, value] of Object.entries(msg.properties.headers)) {
        if (value !== undefined) {
          headerObj[key] = value;
        }
      }
      extractedHeaders = Headers.unmarshal(headerObj);
    }
    
    const message = UserSignedUpPayloadModule.unmarshal(receivedData);
    onDataCallback({err: undefined, msg: message, headers: extractedHeaders, amqpMsg: msg});
  }
}, options);
      resolve(channel);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * AMQP publish operation for exchange \`noparameters\`
 *
  * @param message to publish
 * @param headers optional headers to include with the message
 * @param amqp the AMQP connection to send over
 * @param options for the AMQP publish exchange operation
 */
function publishToNoParameterExchange({
  message, 
  headers, 
  amqp, 
  options
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  headers?: Headers, 
  amqp: Amqp.Connection, 
  options?: {exchange: string | undefined} & Amqp.Options.Publish
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    const exchange = options?.exchange ?? 'undefined';
    if(!exchange) {
      return reject('No exchange value found, please provide one')
    }
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
const channel = await amqp.createChannel();
const routingKey = 'noparameters';
// Set up message properties (headers) if provided
let publishOptions = { ...options };
if (headers) {
  const headerData = headers.marshal();
  const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
  publishOptions.headers = {};
  for (const [key, value] of Object.entries(parsedHeaders)) {
    if (value !== undefined) {
      publishOptions.headers[key] = value;
    }
  }
}
channel.publish(exchange, routingKey, Buffer.from(dataToSend), publishOptions);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * AMQP publish operation for queue \`noparameters\`
 *
  * @param message to publish
 * @param headers optional headers to include with the message
 * @param amqp the AMQP connection to send over
 * @param options for the AMQP publish queue operation
 */
function publishToNoParameterQueue({
  message, 
  headers, 
  amqp, 
  options
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  headers?: Headers, 
  amqp: Amqp.Connection, 
  options?: Amqp.Options.Publish
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
const channel = await amqp.createChannel();
const queue = 'noparameters';
// Set up message properties (headers) if provided
let publishOptions = { ...options };
if (headers) {
  const headerData = headers.marshal();
  const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
  publishOptions.headers = {};
  for (const [key, value] of Object.entries(parsedHeaders)) {
    if (value !== undefined) {
      publishOptions.headers[key] = value;
    }
  }
}
channel.sendToQueue(queue, Buffer.from(dataToSend), publishOptions);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * AMQP subscribe operation for queue \`noparameters\`
 *
  * @param {subscribeToNoParameterQueueCallback} onDataCallback to call when messages are received
 * @param amqp the AMQP connection to receive from
 * @param options for the AMQP subscribe queue operation
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToNoParameterQueue({
  onDataCallback, 
  amqp, 
  options, 
  skipMessageValidation = false
}: {
  onDataCallback: (params: {err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, headers?: Headers, amqpMsg?: Amqp.ConsumeMessage}) => void, 
  amqp: Amqp.Connection, 
  options?: Amqp.Options.Consume, 
  skipMessageValidation?: boolean
}): Promise<Amqp.Channel> {
  return new Promise(async (resolve, reject) => {
    try {
      const channel = await amqp.createChannel();
const queue = 'noparameters';
await channel.assertQueue(queue, { durable: true });

channel.consume(queue, (msg) => {
  if (msg !== null) {
    const receivedData = msg.content.toString()
    // Extract headers if present
    let extractedHeaders: Headers | undefined = undefined;
    if (msg.properties && msg.properties.headers) {
      const headerObj: Record<string, any> = {};
      for (const [key, value] of Object.entries(msg.properties.headers)) {
        if (value !== undefined) {
          headerObj[key] = value;
        }
      }
      extractedHeaders = Headers.unmarshal(headerObj);
    }
    
    const message = UserSignedUpPayloadModule.unmarshal(receivedData);
    onDataCallback({err: undefined, msg: message, headers: extractedHeaders, amqpMsg: msg});
  }
}, options);
      resolve(channel);
    } catch (e: any) {
      reject(e);
    }
  });
}

export { publishToUserSignedupExchange, publishToUserSignedupQueue, subscribeToUserSignedupQueue, publishToNoParameterExchange, publishToNoParameterQueue, subscribeToNoParameterQueue };
"
`;

exports[`channels typescript protocol-specific code generation should generate EventSource protocol code with parameters and headers: event_source-index 1`] = `
"import * as event_source from './event_source';

export {event_source};
"
`;

exports[`channels typescript protocol-specific code generation should generate EventSource protocol code with parameters and headers: event_source-protocol-code 1`] = `
"import * as TestPayloadModelModule from './../../../../../payloads/TestPayloadModel';
import {TestParameter} from './../../../../../parameters/TestParameter';
import {TestHeaders} from './../../../../../headers/TestHeaders';
import { fetchEventSource, EventStreamContentType, EventSourceMessage } from '@microsoft/fetch-event-source';
import { NextFunction, Request, Response, Router } from 'express';

/**
 * Event source fetch for \`user/signedup/{my_parameter}/{enum_parameter}\`
 *
  * @param callback to call when receiving events
 * @param parameters for listening
 * @param headers optional headers to include with the EventSource connection
 * @param options additionally used to handle the event source
 * @param skipMessageValidation turn off runtime validation of incoming messages
 * @returns A cleanup function to abort the connection
 */
function listenForUserSignedup({
  callback, 
  parameters, 
  headers, 
  options, 
  skipMessageValidation = false
}: {
  callback: (params: {error?: Error, messageEvent?: UserSignedUpPayloadModule.UserSignedUpPayload}) => void, 
  parameters: Parameter, 
  headers?: Headers, 
  options: {authorization?: string, onClose?: (err?: string) => void, baseUrl: string, headers?: Record<string, string>}, 
  skipMessageValidation?: boolean
}): (() => void) {
	const controller = new AbortController();
	let eventsUrl: string = parameters.getChannelWithParameters('user/signedup/{my_parameter}/{enum_parameter}');
	const url = \`\${options.baseUrl}/\${eventsUrl}\`
  const requestHeaders: Record<string, string> = {
	  ...options.headers ?? {},
    Accept: 'text/event-stream'
  }
  if(options.authorization) {
    requestHeaders['authorization'] = \`Bearer \${options?.authorization}\`;
  }
  // Add headers from AsyncAPI specification if provided
  if (headers) {
    const asyncApiHeaderData = headers.marshal();
    const parsedAsyncApiHeaders = typeof asyncApiHeaderData === 'string' ? JSON.parse(asyncApiHeaderData) : asyncApiHeaderData;
    for (const [key, value] of Object.entries(parsedAsyncApiHeaders)) {
      if (value !== undefined) {
        requestHeaders[key] = String(value);
      }
    }
  }
  
	fetchEventSource(\`\${url}\`, {
		method: 'GET',
		headers: requestHeaders,
		signal: controller.signal,
		onmessage: (ev: EventSourceMessage) => {
      const receivedData = ev.data;
      
      const callbackData = UserSignedUpPayloadModule.unmarshal(receivedData);
			callback({error: undefined, messageEvent: callbackData});
		},
		onerror: (err) => {
			options.onClose?.(err);
		},
		onclose: () => {
			options.onClose?.();
		},
		async onopen(response: { ok: any; headers: any; status: number }) {
			if (response.ok && response.headers.get('content-type') === EventStreamContentType) {
				return // everything's good
			} else if (response.status >= 400 && response.status < 500 && response.status !== 429) {
				// client-side errors are usually non-retriable:
				callback({error: new Error('Client side error, could not open event connection'), messageEvent: undefined})
			} else {
				callback({error: new Error('Unknown error, could not open event connection'), messageEvent: undefined});
			}
		},
	});
	
	return () => {
		controller.abort();
	};
}


function registerUserSignedup({
  router, 
  callback
}: {
  router: Router, 
  callback: ((req: Request, res: Response, next: NextFunction, parameters: Parameter, sendEvent: (message: UserSignedUpPayloadModule.UserSignedUpPayload) => void) => void) | ((req: Request, res: Response, next: NextFunction, parameters: Parameter, sendEvent: (message: UserSignedUpPayloadModule.UserSignedUpPayload) => void) => Promise<void>)
}): void {
  const event = '/user/signedup/:my_parameter/:enum_parameter';
  router.get(event, async (req, res, next) => {
    const listenParameters = Parameter.createFromChannel(req.originalUrl.startsWith('/') ? req.originalUrl.slice(1) : req.originalUrl, 'user/signedup/{my_parameter}/{enum_parameter}', /^user\\/signedup\\/([^.]*)\\/([^.]*)$/);
    res.writeHead(200, {
      'Cache-Control': 'no-cache, no-transform',
      'Content-Type': 'text/event-stream',
      Connection: 'keep-alive',
      'Access-Control-Allow-Origin': '*',
    })
    const sendEventCallback = (message: UserSignedUpPayloadModule.UserSignedUpPayload) => {
      if (res.closed) {
        return
      }
      res.write(\`event: \${event}\\n\`)
      res.write(\`data: \${UserSignedUpPayloadModule.marshal(message)}\\n\\n\`)
    }
    await callback(req, res, next, listenParameters, sendEventCallback)
  })
}


/**
 * Event source fetch for \`noparameters\`
 *
  * @param callback to call when receiving events
 * @param headers optional headers to include with the EventSource connection
 * @param options additionally used to handle the event source
 * @param skipMessageValidation turn off runtime validation of incoming messages
 * @returns A cleanup function to abort the connection
 */
function listenForNoParameter({
  callback, 
  headers, 
  options, 
  skipMessageValidation = false
}: {
  callback: (params: {error?: Error, messageEvent?: UserSignedUpPayloadModule.UserSignedUpPayload}) => void, 
  headers?: Headers, 
  options: {authorization?: string, onClose?: (err?: string) => void, baseUrl: string, headers?: Record<string, string>}, 
  skipMessageValidation?: boolean
}): (() => void) {
	const controller = new AbortController();
	let eventsUrl: string = 'noparameters';
	const url = \`\${options.baseUrl}/\${eventsUrl}\`
  const requestHeaders: Record<string, string> = {
	  ...options.headers ?? {},
    Accept: 'text/event-stream'
  }
  if(options.authorization) {
    requestHeaders['authorization'] = \`Bearer \${options?.authorization}\`;
  }
  // Add headers from AsyncAPI specification if provided
  if (headers) {
    const asyncApiHeaderData = headers.marshal();
    const parsedAsyncApiHeaders = typeof asyncApiHeaderData === 'string' ? JSON.parse(asyncApiHeaderData) : asyncApiHeaderData;
    for (const [key, value] of Object.entries(parsedAsyncApiHeaders)) {
      if (value !== undefined) {
        requestHeaders[key] = String(value);
      }
    }
  }
  
	fetchEventSource(\`\${url}\`, {
		method: 'GET',
		headers: requestHeaders,
		signal: controller.signal,
		onmessage: (ev: EventSourceMessage) => {
      const receivedData = ev.data;
      
      const callbackData = UserSignedUpPayloadModule.unmarshal(receivedData);
			callback({error: undefined, messageEvent: callbackData});
		},
		onerror: (err) => {
			options.onClose?.(err);
		},
		onclose: () => {
			options.onClose?.();
		},
		async onopen(response: { ok: any; headers: any; status: number }) {
			if (response.ok && response.headers.get('content-type') === EventStreamContentType) {
				return // everything's good
			} else if (response.status >= 400 && response.status < 500 && response.status !== 429) {
				// client-side errors are usually non-retriable:
				callback({error: new Error('Client side error, could not open event connection'), messageEvent: undefined})
			} else {
				callback({error: new Error('Unknown error, could not open event connection'), messageEvent: undefined});
			}
		},
	});
	
	return () => {
		controller.abort();
	};
}


function registerNoParameter({
  router, 
  callback
}: {
  router: Router, 
  callback: ((req: Request, res: Response, next: NextFunction, sendEvent: (message: UserSignedUpPayloadModule.UserSignedUpPayload) => void) => void) | ((req: Request, res: Response, next: NextFunction, sendEvent: (message: UserSignedUpPayloadModule.UserSignedUpPayload) => void) => Promise<void>)
}): void {
  const event = '/noparameters';
  router.get(event, async (req, res, next) => {
    
    res.writeHead(200, {
      'Cache-Control': 'no-cache, no-transform',
      'Content-Type': 'text/event-stream',
      Connection: 'keep-alive',
      'Access-Control-Allow-Origin': '*',
    })
    const sendEventCallback = (message: UserSignedUpPayloadModule.UserSignedUpPayload) => {
      if (res.closed) {
        return
      }
      res.write(\`event: \${event}\\n\`)
      res.write(\`data: \${UserSignedUpPayloadModule.marshal(message)}\\n\\n\`)
    }
    await callback(req, res, next,  sendEventCallback)
  })
}


export { listenForUserSignedup, registerUserSignedup, listenForNoParameter, registerNoParameter };
"
`;

exports[`channels typescript protocol-specific code generation should generate HTTP client protocol code for request/reply: http_client-index 1`] = `
"import * as http_client from './http_client';

export {http_client};
"
`;

exports[`channels typescript protocol-specific code generation should generate HTTP client protocol code for request/reply: http_client-protocol-code 1`] = `
"import * as TestPayloadModelModule from './../../../../../payloads/TestPayloadModel';
import { URLSearchParams, URL } from 'url';
import * as NodeFetch from 'node-fetch';

// ============================================================================
// Common Types - Shared across all HTTP client functions
// ============================================================================

/**
 * Standard HTTP response interface that wraps fetch-like responses
 */
export interface HttpResponse {
  ok: boolean;
  status: number;
  statusText: string;
  headers?: Headers | Record<string, string>;
  json: () => Record<any, any> | Promise<Record<any, any>>;
}

/**
 * Pagination info extracted from response
 */
export interface PaginationInfo {
  /** Total number of items (if available from headers like X-Total-Count) */
  totalCount?: number;
  /** Total number of pages (if available) */
  totalPages?: number;
  /** Current page/offset */
  currentOffset?: number;
  /** Items per page */
  limit?: number;
  /** Next cursor (for cursor-based pagination) */
  nextCursor?: string;
  /** Previous cursor */
  prevCursor?: string;
  /** Whether there are more items */
  hasMore?: boolean;
}

/**
 * Rich response wrapper returned by HTTP client functions
 */
export interface HttpClientResponse<T> {
  /** The deserialized response payload */
  data: T;
  /** HTTP status code */
  status: number;
  /** HTTP status text */
  statusText: string;
  /** Response headers */
  headers: Record<string, string>;
  /** Raw JSON response before deserialization */
  rawData: Record<string, any>;
  /** Pagination info extracted from response (if applicable) */
  pagination?: PaginationInfo;
  /** Fetch the next page (if pagination is configured and more data exists) */
  getNextPage?: () => Promise<HttpClientResponse<T>>;
  /** Fetch the previous page (if pagination is configured) */
  getPrevPage?: () => Promise<HttpClientResponse<T>>;
  /** Check if there's a next page */
  hasNextPage?: () => boolean;
  /** Check if there's a previous page */
  hasPrevPage?: () => boolean;
}

/**
 * HTTP request parameters passed to the request hook
 */
export interface HttpRequestParams {
  url: string;
  headers?: Record<string, string | string[]>;
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
  credentials?: RequestCredentials;
  body?: any;
}

/**
 * Token response structure for OAuth2 flows
 */
export interface TokenResponse {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
}

// ============================================================================
// Security Configuration Types - Grouped for better autocomplete
// ============================================================================

/**
 * Bearer token authentication configuration
 */
export interface BearerAuth {
  type: 'bearer';
  token: string;
}

/**
 * Basic authentication configuration (username/password)
 */
export interface BasicAuth {
  type: 'basic';
  username: string;
  password: string;
}

/**
 * API key authentication configuration
 */
export interface ApiKeyAuth {
  type: 'apiKey';
  key: string;
  name?: string;        // Name of the API key parameter (default: 'X-API-Key')
  in?: 'header' | 'query'; // Where to place the API key (default: 'header')
}

/**
 * OAuth2 authentication configuration
 *
 * Supports server-side flows only:
 * - client_credentials: Server-to-server authentication
 * - password: Resource owner password credentials (legacy, not recommended)
 * - Pre-obtained accessToken: For tokens obtained via browser-based flows
 *
 * For browser-based flows (implicit, authorization_code), obtain the token
 * separately and pass it as accessToken.
 */
export interface OAuth2Auth {
  type: 'oauth2';
  /** Pre-obtained access token (required if not using a server-side flow) */
  accessToken?: string;
  /** Refresh token for automatic token renewal on 401 */
  refreshToken?: string;
  /** Token endpoint URL (required for client_credentials/password flows and token refresh) */
  tokenUrl?: string;
  /** Client ID (required for flows and token refresh) */
  clientId?: string;
  /** Client secret (optional, depends on OAuth provider) */
  clientSecret?: string;
  /** Requested scopes */
  scopes?: string[];
  /** Server-side flow type */
  flow?: 'password' | 'client_credentials';
  /** Username for password flow */
  username?: string;
  /** Password for password flow */
  password?: string;
  /** Callback when tokens are refreshed (for caching/persistence) */
  onTokenRefresh?: (newTokens: TokenResponse) => void;
}

/**
 * Union type for all authentication methods - provides autocomplete support
 */
export type AuthConfig = BearerAuth | BasicAuth | ApiKeyAuth | OAuth2Auth;

// ============================================================================
// Pagination Types
// ============================================================================

/**
 * Where to place pagination parameters
 */
export type PaginationLocation = 'query' | 'header';

/**
 * Offset-based pagination configuration
 */
export interface OffsetPagination {
  type: 'offset';
  in?: PaginationLocation;  // Where to place params (default: 'query')
  offset: number;
  limit: number;
  offsetParam?: string;  // Param name for offset (default: 'offset' for query, 'X-Offset' for header)
  limitParam?: string;   // Param name for limit (default: 'limit' for query, 'X-Limit' for header)
}

/**
 * Cursor-based pagination configuration
 */
export interface CursorPagination {
  type: 'cursor';
  in?: PaginationLocation;  // Where to place params (default: 'query')
  cursor?: string;
  limit?: number;
  cursorParam?: string;  // Param name for cursor (default: 'cursor' for query, 'X-Cursor' for header)
  limitParam?: string;   // Param name for limit (default: 'limit' for query, 'X-Limit' for header)
}

/**
 * Page-based pagination configuration
 */
export interface PagePagination {
  type: 'page';
  in?: PaginationLocation;  // Where to place params (default: 'query')
  page: number;
  pageSize: number;
  pageParam?: string;     // Param name for page (default: 'page' for query, 'X-Page' for header)
  pageSizeParam?: string; // Param name for page size (default: 'pageSize' for query, 'X-Page-Size' for header)
}

/**
 * Range-based pagination (typically used with headers)
 * Follows RFC 7233 style: Range: items=0-24
 */
export interface RangePagination {
  type: 'range';
  in?: 'header';  // Range pagination is typically header-only
  start: number;
  end: number;
  unit?: string;        // Range unit (default: 'items')
  rangeHeader?: string; // Header name (default: 'Range')
}

/**
 * Union type for all pagination methods
 */
export type PaginationConfig = OffsetPagination | CursorPagination | PagePagination | RangePagination;

// ============================================================================
// Retry Configuration
// ============================================================================

/**
 * Retry policy configuration for failed requests
 */
export interface RetryConfig {
  maxRetries?: number;           // Maximum number of retry attempts (default: 3)
  initialDelayMs?: number;       // Initial delay before first retry (default: 1000)
  maxDelayMs?: number;           // Maximum delay between retries (default: 30000)
  backoffMultiplier?: number;    // Multiplier for exponential backoff (default: 2)
  retryableStatusCodes?: number[]; // Status codes to retry (default: [408, 429, 500, 502, 503, 504])
  retryOnNetworkError?: boolean; // Retry on network errors (default: true)
  onRetry?: (attempt: number, delay: number, error: Error) => void; // Callback on each retry
}

// ============================================================================
// Hooks Configuration - Extensible callback system
// ============================================================================

/**
 * Hooks for customizing HTTP client behavior
 */
export interface HttpHooks {
  /**
   * Called before each request to transform/modify the request parameters
   * Return modified params or undefined to use original
   */
  beforeRequest?: (params: HttpRequestParams) => HttpRequestParams | Promise<HttpRequestParams>;

  /**
   * The actual request implementation - allows swapping fetch for axios, etc.
   * Default: uses node-fetch
   */
  makeRequest?: (params: HttpRequestParams) => Promise<HttpResponse>;

  /**
   * Called after each response for logging, metrics, etc.
   * Can transform the response before it's processed
   */
  afterResponse?: (response: HttpResponse, params: HttpRequestParams) => HttpResponse | Promise<HttpResponse>;

  /**
   * Called on request error for logging, error transformation, etc.
   */
  onError?: (error: Error, params: HttpRequestParams) => Error | Promise<Error>;
}

// ============================================================================
// Common Request Context
// ============================================================================

/**
 * Base context shared by all HTTP client functions
 */
export interface HttpClientContext {
  server?: string;
  path?: string;

  // Authentication - grouped for better autocomplete
  auth?: AuthConfig;

  // Pagination configuration
  pagination?: PaginationConfig;

  // Retry configuration
  retry?: RetryConfig;

  // Hooks for extensibility
  hooks?: HttpHooks;

  // Additional options
  additionalHeaders?: Record<string, string | string[]>;

  // Query parameters
  queryParams?: Record<string, string | number | boolean | undefined>;
}

// ============================================================================
// Helper Functions - Shared logic extracted for reuse
// ============================================================================

/**
 * Default retry configuration
 */
const DEFAULT_RETRY_CONFIG: Required<RetryConfig> = {
  maxRetries: 3,
  initialDelayMs: 1000,
  maxDelayMs: 30000,
  backoffMultiplier: 2,
  retryableStatusCodes: [408, 429, 500, 502, 503, 504],
  retryOnNetworkError: true,
  onRetry: () => {},
};

/**
 * Default request hook implementation using node-fetch
 */
const defaultMakeRequest = async (params: HttpRequestParams): Promise<HttpResponse> => {
  return NodeFetch.default(params.url, {
    body: params.body,
    method: params.method,
    headers: params.headers
  }) as unknown as HttpResponse;
};

/**
 * Apply authentication to headers and URL based on auth config
 */
function applyAuth(
  auth: AuthConfig | undefined,
  headers: Record<string, string | string[]>,
  url: string
): { headers: Record<string, string | string[]>; url: string } {
  if (!auth) return { headers, url };

  switch (auth.type) {
    case 'bearer':
      headers['Authorization'] = \`Bearer \${auth.token}\`;
      break;

    case 'basic': {
      const credentials = Buffer.from(\`\${auth.username}:\${auth.password}\`).toString('base64');
      headers['Authorization'] = \`Basic \${credentials}\`;
      break;
    }

    case 'apiKey': {
      const keyName = auth.name ?? 'X-API-Key';
      const keyIn = auth.in ?? 'header';

      if (keyIn === 'header') {
        headers[keyName] = auth.key;
      } else {
        const separator = url.includes('?') ? '&' : '?';
        url = \`\${url}\${separator}\${keyName}=\${encodeURIComponent(auth.key)}\`;
      }
      break;
    }

    case 'oauth2': {
      // If we have an access token, use it directly
      // Token flows (client_credentials, password) are handled separately
      if (auth.accessToken) {
        headers['Authorization'] = \`Bearer \${auth.accessToken}\`;
      }
      break;
    }
  }

  return { headers, url };
}

/**
 * Validate OAuth2 configuration based on flow type
 */
function validateOAuth2Config(auth: OAuth2Auth): void {
  // If using a flow, validate required fields
  switch (auth.flow) {
    case 'client_credentials':
      if (!auth.tokenUrl) throw new Error('OAuth2 Client Credentials flow requires tokenUrl');
      if (!auth.clientId) throw new Error('OAuth2 Client Credentials flow requires clientId');
      break;

    case 'password':
      if (!auth.tokenUrl) throw new Error('OAuth2 Password flow requires tokenUrl');
      if (!auth.clientId) throw new Error('OAuth2 Password flow requires clientId');
      if (!auth.username) throw new Error('OAuth2 Password flow requires username');
      if (!auth.password) throw new Error('OAuth2 Password flow requires password');
      break;

    default:
      // No flow specified - must have accessToken for OAuth2 to work
      if (!auth.accessToken && !auth.flow) {
        // This is fine - token refresh can still work if refreshToken is provided
        // Or the request will just be made without auth
      }
      break;
  }
}

/**
 * Apply pagination parameters to URL and/or headers based on configuration
 */
function applyPagination(
  pagination: PaginationConfig | undefined,
  url: string,
  headers: Record<string, string | string[]>
): { url: string; headers: Record<string, string | string[]> } {
  if (!pagination) return { url, headers };

  const location = pagination.in ?? 'query';
  const isHeader = location === 'header';

  // Helper to get default param names based on location
  const getDefaultName = (queryName: string, headerName: string) =>
    isHeader ? headerName : queryName;

  const queryParams = new URLSearchParams();
  const headerParams: Record<string, string> = {};

  const addParam = (name: string, value: string) => {
    if (isHeader) {
      headerParams[name] = value;
    } else {
      queryParams.append(name, value);
    }
  };

  switch (pagination.type) {
    case 'offset':
      addParam(
        pagination.offsetParam ?? getDefaultName('offset', 'X-Offset'),
        String(pagination.offset)
      );
      addParam(
        pagination.limitParam ?? getDefaultName('limit', 'X-Limit'),
        String(pagination.limit)
      );
      break;

    case 'cursor':
      if (pagination.cursor) {
        addParam(
          pagination.cursorParam ?? getDefaultName('cursor', 'X-Cursor'),
          pagination.cursor
        );
      }
      if (pagination.limit !== undefined) {
        addParam(
          pagination.limitParam ?? getDefaultName('limit', 'X-Limit'),
          String(pagination.limit)
        );
      }
      break;

    case 'page':
      addParam(
        pagination.pageParam ?? getDefaultName('page', 'X-Page'),
        String(pagination.page)
      );
      addParam(
        pagination.pageSizeParam ?? getDefaultName('pageSize', 'X-Page-Size'),
        String(pagination.pageSize)
      );
      break;

    case 'range': {
      // Range pagination is always header-based (RFC 7233 style)
      const unit = pagination.unit ?? 'items';
      const headerName = pagination.rangeHeader ?? 'Range';
      headerParams[headerName] = \`\${unit}=\${pagination.start}-\${pagination.end}\`;
      break;
    }
  }

  // Apply query params to URL
  const queryString = queryParams.toString();
  if (queryString) {
    const separator = url.includes('?') ? '&' : '?';
    url = \`\${url}\${separator}\${queryString}\`;
  }

  // Merge header params
  const updatedHeaders = { ...headers, ...headerParams };

  return { url, headers: updatedHeaders };
}

/**
 * Apply query parameters to URL
 */
function applyQueryParams(queryParams: Record<string, string | number | boolean | undefined> | undefined, url: string): string {
  if (!queryParams) return url;

  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(queryParams)) {
    if (value !== undefined) {
      params.append(key, String(value));
    }
  }

  const paramString = params.toString();
  if (!paramString) return url;

  const separator = url.includes('?') ? '&' : '?';
  return \`\${url}\${separator}\${paramString}\`;
}

/**
 * Sleep for a specified number of milliseconds
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Calculate delay for exponential backoff
 */
function calculateBackoffDelay(
  attempt: number,
  config: Required<RetryConfig>
): number {
  const delay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attempt - 1);
  return Math.min(delay, config.maxDelayMs);
}

/**
 * Determine if a request should be retried based on error/response
 */
function shouldRetry(
  error: Error | null,
  response: HttpResponse | null,
  config: Required<RetryConfig>,
  attempt: number
): boolean {
  if (attempt >= config.maxRetries) return false;

  if (error && config.retryOnNetworkError) return true;

  if (response && config.retryableStatusCodes.includes(response.status)) return true;

  return false;
}

/**
 * Execute request with retry logic
 */
async function executeWithRetry(
  params: HttpRequestParams,
  makeRequest: (params: HttpRequestParams) => Promise<HttpResponse>,
  retryConfig?: RetryConfig
): Promise<HttpResponse> {
  const config = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };
  let lastError: Error | null = null;
  let lastResponse: HttpResponse | null = null;

  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        const delay = calculateBackoffDelay(attempt, config);
        config.onRetry(attempt, delay, lastError ?? new Error('Retry attempt'));
        await sleep(delay);
      }

      const response = await makeRequest(params);

      // Check if we should retry this response
      if (!shouldRetry(null, response, config, attempt + 1)) {
        return response;
      }

      lastResponse = response;
      lastError = new Error(\`HTTP Error: \${response.status} \${response.statusText}\`);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (!shouldRetry(lastError, null, config, attempt + 1)) {
        throw lastError;
      }
    }
  }

  // All retries exhausted
  if (lastResponse) {
    return lastResponse;
  }
  throw lastError ?? new Error('Request failed after retries');
}

/**
 * Handle OAuth2 token flows (client_credentials, password)
 */
async function handleOAuth2TokenFlow(
  auth: OAuth2Auth,
  originalParams: HttpRequestParams,
  makeRequest: (params: HttpRequestParams) => Promise<HttpResponse>,
  retryConfig?: RetryConfig
): Promise<HttpResponse | null> {
  if (!auth.flow || !auth.tokenUrl) return null;

  const params = new URLSearchParams();

  if (auth.flow === 'client_credentials') {
    params.append('grant_type', 'client_credentials');
    params.append('client_id', auth.clientId!);
  } else if (auth.flow === 'password') {
    params.append('grant_type', 'password');
    params.append('username', auth.username || '');
    params.append('password', auth.password || '');
    params.append('client_id', auth.clientId!);
  } else {
    return null;
  }

  if (auth.clientSecret) {
    params.append('client_secret', auth.clientSecret);
  }
  if (auth.scopes && auth.scopes.length > 0) {
    params.append('scope', auth.scopes.join(' '));
  }

  const authHeaders: Record<string, string> = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  // Use basic auth for client credentials if both client ID and secret are provided
  if (auth.flow === 'client_credentials' && auth.clientId && auth.clientSecret) {
    const credentials = Buffer.from(\`\${auth.clientId}:\${auth.clientSecret}\`).toString('base64');
    authHeaders['Authorization'] = \`Basic \${credentials}\`;
    params.delete('client_id');
    params.delete('client_secret');
  }

  const tokenResponse = await NodeFetch.default(auth.tokenUrl, {
    method: 'POST',
    headers: authHeaders,
    body: params.toString()
  });

  if (!tokenResponse.ok) {
    throw new Error(\`OAuth2 token request failed: \${tokenResponse.statusText}\`);
  }

  const tokenData = await tokenResponse.json();
  const tokens: TokenResponse = {
    accessToken: tokenData.access_token,
    refreshToken: tokenData.refresh_token,
    expiresIn: tokenData.expires_in
  };

  // Notify the client about the tokens
  if (auth.onTokenRefresh) {
    auth.onTokenRefresh(tokens);
  }

  // Retry the original request with the new token
  const updatedHeaders = { ...originalParams.headers };
  updatedHeaders['Authorization'] = \`Bearer \${tokens.accessToken}\`;

  return executeWithRetry({ ...originalParams, headers: updatedHeaders }, makeRequest, retryConfig);
}

/**
 * Handle OAuth2 token refresh on 401 response
 */
async function handleTokenRefresh(
  auth: OAuth2Auth,
  originalParams: HttpRequestParams,
  makeRequest: (params: HttpRequestParams) => Promise<HttpResponse>,
  retryConfig?: RetryConfig
): Promise<HttpResponse | null> {
  if (!auth.refreshToken || !auth.tokenUrl || !auth.clientId) return null;

  const refreshResponse = await NodeFetch.default(auth.tokenUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: auth.refreshToken,
      client_id: auth.clientId,
      ...(auth.clientSecret ? { client_secret: auth.clientSecret } : {})
    }).toString()
  });

  if (!refreshResponse.ok) {
    throw new Error('Unauthorized');
  }

  const tokenData = await refreshResponse.json();
  const newTokens: TokenResponse = {
    accessToken: tokenData.access_token,
    refreshToken: tokenData.refresh_token || auth.refreshToken,
    expiresIn: tokenData.expires_in
  };

  // Notify the client about the refreshed tokens
  if (auth.onTokenRefresh) {
    auth.onTokenRefresh(newTokens);
  }

  // Retry the original request with the new token
  const updatedHeaders = { ...originalParams.headers };
  updatedHeaders['Authorization'] = \`Bearer \${newTokens.accessToken}\`;

  return executeWithRetry({ ...originalParams, headers: updatedHeaders }, makeRequest, retryConfig);
}

/**
 * Handle HTTP error status codes with standardized messages
 */
function handleHttpError(status: number, statusText: string): never {
  switch (status) {
    case 401:
      throw new Error('Unauthorized');
    case 403:
      throw new Error('Forbidden');
    case 404:
      throw new Error('Not Found');
    case 500:
      throw new Error('Internal Server Error');
    default:
      throw new Error(\`HTTP Error: \${status} \${statusText}\`);
  }
}

/**
 * Extract headers from response into a plain object
 */
function extractHeaders(response: HttpResponse): Record<string, string> {
  const headers: Record<string, string> = {};

  if (response.headers) {
    if (typeof (response.headers as any).forEach === 'function') {
      // Headers object (fetch API)
      (response.headers as Headers).forEach((value, key) => {
        headers[key.toLowerCase()] = value;
      });
    } else {
      // Plain object
      for (const [key, value] of Object.entries(response.headers)) {
        headers[key.toLowerCase()] = value;
      }
    }
  }

  return headers;
}

/**
 * Extract pagination info from response headers
 */
function extractPaginationInfo(
  headers: Record<string, string>,
  currentPagination?: PaginationConfig
): PaginationInfo | undefined {
  const info: PaginationInfo = {};
  let hasPaginationInfo = false;

  // Common total count headers
  const totalCount = headers['x-total-count'] || headers['x-total'] || headers['total-count'];
  if (totalCount) {
    info.totalCount = parseInt(totalCount, 10);
    hasPaginationInfo = true;
  }

  // Total pages
  const totalPages = headers['x-total-pages'] || headers['x-page-count'];
  if (totalPages) {
    info.totalPages = parseInt(totalPages, 10);
    hasPaginationInfo = true;
  }

  // Next cursor
  const nextCursor = headers['x-next-cursor'] || headers['x-cursor-next'];
  if (nextCursor) {
    info.nextCursor = nextCursor;
    info.hasMore = true;
    hasPaginationInfo = true;
  }

  // Previous cursor
  const prevCursor = headers['x-prev-cursor'] || headers['x-cursor-prev'];
  if (prevCursor) {
    info.prevCursor = prevCursor;
    hasPaginationInfo = true;
  }

  // Has more indicator
  const hasMore = headers['x-has-more'] || headers['x-has-next'];
  if (hasMore) {
    info.hasMore = hasMore.toLowerCase() === 'true' || hasMore === '1';
    hasPaginationInfo = true;
  }

  // Parse Link header (RFC 5988)
  const linkHeader = headers['link'];
  if (linkHeader) {
    const links = parseLinkHeader(linkHeader);
    if (links.next) {
      info.hasMore = true;
      hasPaginationInfo = true;
    }
  }

  // Include current pagination state
  if (currentPagination) {
    switch (currentPagination.type) {
      case 'offset':
        info.currentOffset = currentPagination.offset;
        info.limit = currentPagination.limit;
        break;
      case 'cursor':
        info.limit = currentPagination.limit;
        break;
      case 'page':
        info.currentOffset = (currentPagination.page - 1) * currentPagination.pageSize;
        info.limit = currentPagination.pageSize;
        break;
      case 'range':
        info.currentOffset = currentPagination.start;
        info.limit = currentPagination.end - currentPagination.start + 1;
        break;
    }
    hasPaginationInfo = true;
  }

  // Calculate hasMore based on total count
  if (info.hasMore === undefined && info.totalCount !== undefined &&
      info.currentOffset !== undefined && info.limit !== undefined) {
    info.hasMore = info.currentOffset + info.limit < info.totalCount;
  }

  return hasPaginationInfo ? info : undefined;
}

/**
 * Parse RFC 5988 Link header
 */
function parseLinkHeader(header: string): Record<string, string> {
  const links: Record<string, string> = {};
  const parts = header.split(',');

  for (const part of parts) {
    const match = part.match(/<([^>]+)>;\\s*rel="?([^";\\s]+)"?/);
    if (match) {
      links[match[2]] = match[1];
    }
  }

  return links;
}

/**
 * Create pagination helper functions for the response
 */
function createPaginationHelpers<T, TContext extends HttpClientContext>(
  currentConfig: TContext,
  paginationInfo: PaginationInfo | undefined,
  requestFn: (config: TContext) => Promise<HttpClientResponse<T>>
): Pick<HttpClientResponse<T>, 'getNextPage' | 'getPrevPage' | 'hasNextPage' | 'hasPrevPage'> {
  const helpers: Pick<HttpClientResponse<T>, 'getNextPage' | 'getPrevPage' | 'hasNextPage' | 'hasPrevPage'> = {};

  if (!currentConfig.pagination) {
    return helpers;
  }

  const pagination = currentConfig.pagination;

  helpers.hasNextPage = () => {
    if (paginationInfo?.hasMore !== undefined) return paginationInfo.hasMore;
    if (paginationInfo?.nextCursor) return true;
    if (paginationInfo?.totalCount !== undefined &&
        paginationInfo.currentOffset !== undefined &&
        paginationInfo.limit !== undefined) {
      return paginationInfo.currentOffset + paginationInfo.limit < paginationInfo.totalCount;
    }
    return false;
  };

  helpers.hasPrevPage = () => {
    if (paginationInfo?.prevCursor) return true;
    if (paginationInfo?.currentOffset !== undefined) {
      return paginationInfo.currentOffset > 0;
    }
    return false;
  };

  helpers.getNextPage = async () => {
    let nextPagination: PaginationConfig;

    switch (pagination.type) {
      case 'offset':
        nextPagination = { ...pagination, offset: pagination.offset + pagination.limit };
        break;
      case 'cursor':
        if (!paginationInfo?.nextCursor) throw new Error('No next cursor available');
        nextPagination = { ...pagination, cursor: paginationInfo.nextCursor };
        break;
      case 'page':
        nextPagination = { ...pagination, page: pagination.page + 1 };
        break;
      case 'range':
        const rangeSize = pagination.end - pagination.start + 1;
        nextPagination = { ...pagination, start: pagination.end + 1, end: pagination.end + rangeSize };
        break;
      default:
        throw new Error('Unsupported pagination type');
    }

    return requestFn({ ...currentConfig, pagination: nextPagination });
  };

  helpers.getPrevPage = async () => {
    let prevPagination: PaginationConfig;

    switch (pagination.type) {
      case 'offset':
        prevPagination = { ...pagination, offset: Math.max(0, pagination.offset - pagination.limit) };
        break;
      case 'cursor':
        if (!paginationInfo?.prevCursor) throw new Error('No previous cursor available');
        prevPagination = { ...pagination, cursor: paginationInfo.prevCursor };
        break;
      case 'page':
        prevPagination = { ...pagination, page: Math.max(1, pagination.page - 1) };
        break;
      case 'range':
        const size = pagination.end - pagination.start + 1;
        const newStart = Math.max(0, pagination.start - size);
        prevPagination = { ...pagination, start: newStart, end: newStart + size - 1 };
        break;
      default:
        throw new Error('Unsupported pagination type');
    }

    return requestFn({ ...currentConfig, pagination: prevPagination });
  };

  return helpers;
}

/**
 * Builds a URL with path parameters replaced
 * @param server - Base server URL
 * @param pathTemplate - Path template with {param} placeholders
 * @param parameters - Parameter object with getChannelWithParameters method
 */
function buildUrlWithParameters<T extends { getChannelWithParameters: (path: string) => string }>(
  server: string,
  pathTemplate: string,
  parameters: T
): string {
  const path = parameters.getChannelWithParameters(pathTemplate);
  return \`\${server}\${path}\`;
}

/**
 * Extracts headers from a typed headers object and merges with additional headers
 */
function applyTypedHeaders(
  typedHeaders: { marshal: () => string } | undefined,
  additionalHeaders: Record<string, string | string[]> | undefined
): Record<string, string | string[]> {
  const headers: Record<string, string | string[]> = {
    'Content-Type': 'application/json',
    ...additionalHeaders
  };

  if (typedHeaders) {
    // Parse the marshalled headers and merge them
    const marshalledHeaders = JSON.parse(typedHeaders.marshal());
    for (const [key, value] of Object.entries(marshalledHeaders)) {
      headers[key] = value as string;
    }
  }

  return headers;
}

// ============================================================================
// Generated HTTP Client Functions
// ============================================================================

export interface GetPingRequestContext extends HttpClientContext {
  requestHeaders?: { marshal: () => string };
}

async function getPingRequest(context: GetPingRequestContext = {}): Promise<HttpClientResponse<PongModule.Pong>> {
  // Apply defaults
  const config = {
    path: '/ping',
    server: 'localhost:3000',
    ...context,
  };

  // Validate OAuth2 config if present
  if (config.auth?.type === 'oauth2') {
    validateOAuth2Config(config.auth);
  }

  // Build headers
  let headers = context.requestHeaders
    ? applyTypedHeaders(context.requestHeaders, config.additionalHeaders)
    : { 'Content-Type': 'application/json', ...config.additionalHeaders } as Record<string, string | string[]>;

  // Build URL
  let url = \`\${config.server}\${config.path}\`;
  url = applyQueryParams(config.queryParams, url);

  // Apply pagination (can affect URL and/or headers)
  const paginationResult = applyPagination(config.pagination, url, headers);
  url = paginationResult.url;
  headers = paginationResult.headers;

  // Apply authentication
  const authResult = applyAuth(config.auth, headers, url);
  headers = authResult.headers;
  url = authResult.url;

  // Prepare body
  const body = undefined;

  // Determine request function
  const makeRequest = config.hooks?.makeRequest ?? defaultMakeRequest;

  // Build request params
  let requestParams: HttpRequestParams = {
    url,
    method: 'GET',
    headers,
    body
  };

  // Apply beforeRequest hook
  if (config.hooks?.beforeRequest) {
    requestParams = await config.hooks.beforeRequest(requestParams);
  }

  try {
    // Execute request with retry logic
    let response = await executeWithRetry(requestParams, makeRequest, config.retry);

    // Apply afterResponse hook
    if (config.hooks?.afterResponse) {
      response = await config.hooks.afterResponse(response, requestParams);
    }

    // Handle OAuth2 token flows that require getting a token first
    if (config.auth?.type === 'oauth2' && !config.auth.accessToken) {
      const tokenFlowResponse = await handleOAuth2TokenFlow(config.auth, requestParams, makeRequest, config.retry);
      if (tokenFlowResponse) {
        response = tokenFlowResponse;
      }
    }

    // Handle 401 with token refresh
    if (response.status === 401 && config.auth?.type === 'oauth2') {
      try {
        const refreshResponse = await handleTokenRefresh(config.auth, requestParams, makeRequest, config.retry);
        if (refreshResponse) {
          response = refreshResponse;
        }
      } catch {
        throw new Error('Unauthorized');
      }
    }

    // Handle error responses
    if (!response.ok) {
      handleHttpError(response.status, response.statusText);
    }

    // Parse response
    const rawData = await response.json();
    const responseData = PongModule.unmarshal(rawData);

    // Extract response metadata
    const responseHeaders = extractHeaders(response);
    const paginationInfo = extractPaginationInfo(responseHeaders, config.pagination);

    // Build response wrapper with pagination helpers
    const result: HttpClientResponse<PongModule.Pong> = {
      data: responseData,
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
      rawData,
      pagination: paginationInfo,
      ...createPaginationHelpers(config, paginationInfo, getPingRequest),
    };

    return result;

  } catch (error) {
    // Apply onError hook if present
    if (config.hooks?.onError && error instanceof Error) {
      throw await config.hooks.onError(error, requestParams);
    }
    throw error;
  }
}

export { getPingRequest };
"
`;

exports[`channels typescript protocol-specific code generation should generate Kafka protocol code with parameters and headers: kafka-index 1`] = `
"import * as kafka from './kafka';

export {kafka};
"
`;

exports[`channels typescript protocol-specific code generation should generate Kafka protocol code with parameters and headers: kafka-protocol-code 1`] = `
"import * as TestPayloadModelModule from './../../../../../payloads/TestPayloadModel';
import {TestParameter} from './../../../../../parameters/TestParameter';
import {TestHeaders} from './../../../../../headers/TestHeaders';
import * as Kafka from 'kafkajs';

/**
 * Kafka publish operation for \`user.signedup.{my_parameter}.{enum_parameter}\`
 *
  * @param message to publish
 * @param parameters for topic substitution
 * @param headers optional headers to include with the message
 * @param kafka the KafkaJS client to publish from
 */
function produceToUserSignedup({
  message, 
  parameters, 
  headers, 
  kafka
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  parameters: Parameter, 
  headers?: Headers, 
  kafka: Kafka.Kafka
}): Promise<Kafka.Producer> {
  return new Promise(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      const producer = kafka.producer();
      await producer.connect();
      // Set up headers if provided
      let messageHeaders: Record<string, string> | undefined = undefined;
      if (headers) {
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        messageHeaders = {};
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            messageHeaders[key] = String(value);
          }
        }
      }

      await producer.send({
        topic: parameters.getChannelWithParameters('user.signedup.{my_parameter}.{enum_parameter}'),
        messages: [
          {
            value: dataToSend,
            headers: messageHeaders
          },
        ],
      });
      resolve(producer);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback consumeFromUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param parameters that was received in the topic
 * @param headers that was received with the message
 * @param kafkaMsg
 */

/**
 * Kafka subscription for \`user.signedup.{my_parameter}.{enum_parameter}\`
 *
  * @param {consumeFromUserSignedupCallback} onDataCallback to call when messages are received
 * @param parameters for topic substitution
 * @param kafka the KafkaJS client to subscribe through
 * @param options when setting up the subscription
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function consumeFromUserSignedup({
  onDataCallback, 
  parameters, 
  kafka, 
  options = {fromBeginning: true, groupId: ''}, 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, parameters?: Parameter, headers?: Headers, kafkaMsg?: Kafka.EachMessagePayload) => void, 
  parameters: Parameter, 
  kafka: Kafka.Kafka, 
  options: {fromBeginning: boolean, groupId: string}, 
  skipMessageValidation?: boolean
}): Promise<Kafka.Consumer> {
  return new Promise(async (resolve, reject) => {
    try {
      if(!options.groupId) {
        return reject('No group ID provided');
      }
      const consumer = kafka.consumer({ groupId: options.groupId });

      
      await consumer.connect();
      await consumer.subscribe({ topic: parameters.getChannelWithParameters('user.signedup.{my_parameter}.{enum_parameter}'), fromBeginning: options.fromBeginning });
      await consumer.run({
        eachMessage: async (kafkaMessage: Kafka.EachMessagePayload) => {
          const { topic, message } = kafkaMessage;
          const receivedData = message.value?.toString()!;
          const parameters = Parameter.createFromChannel(topic, 'user.signedup.{my_parameter}.{enum_parameter}', /^user.signedup.([^.]*).([^.]*)$/);
          
          // Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (message.headers) {
            const headerObj: Record<string, any> = {};
            for (const [key, value] of Object.entries(message.headers)) {
              if (value !== undefined) {
                headerObj[key] = value.toString();
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }

const callbackData = UserSignedUpPayloadModule.unmarshal(receivedData);
onDataCallback(undefined, callbackData, parameters, extractedHeaders, kafkaMessage);
        }
      });
      resolve(consumer);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Kafka publish operation for \`noparameters\`
 *
  * @param message to publish
 * @param headers optional headers to include with the message
 * @param kafka the KafkaJS client to publish from
 */
function produceToNoParameter({
  message, 
  headers, 
  kafka
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  headers?: Headers, 
  kafka: Kafka.Kafka
}): Promise<Kafka.Producer> {
  return new Promise(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      const producer = kafka.producer();
      await producer.connect();
      // Set up headers if provided
      let messageHeaders: Record<string, string> | undefined = undefined;
      if (headers) {
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        messageHeaders = {};
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            messageHeaders[key] = String(value);
          }
        }
      }

      await producer.send({
        topic: 'noparameters',
        messages: [
          {
            value: dataToSend,
            headers: messageHeaders
          },
        ],
      });
      resolve(producer);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback consumeFromNoParameterCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param headers that was received with the message
 * @param kafkaMsg
 */

/**
 * Kafka subscription for \`noparameters\`
 *
  * @param {consumeFromNoParameterCallback} onDataCallback to call when messages are received
 * @param kafka the KafkaJS client to subscribe through
 * @param options when setting up the subscription
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function consumeFromNoParameter({
  onDataCallback, 
  kafka, 
  options = {fromBeginning: true, groupId: ''}, 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, headers?: Headers, kafkaMsg?: Kafka.EachMessagePayload) => void, 
  kafka: Kafka.Kafka, 
  options: {fromBeginning: boolean, groupId: string}, 
  skipMessageValidation?: boolean
}): Promise<Kafka.Consumer> {
  return new Promise(async (resolve, reject) => {
    try {
      if(!options.groupId) {
        return reject('No group ID provided');
      }
      const consumer = kafka.consumer({ groupId: options.groupId });

      
      await consumer.connect();
      await consumer.subscribe({ topic: 'noparameters', fromBeginning: options.fromBeginning });
      await consumer.run({
        eachMessage: async (kafkaMessage: Kafka.EachMessagePayload) => {
          const { topic, message } = kafkaMessage;
          const receivedData = message.value?.toString()!;
          
          
          // Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (message.headers) {
            const headerObj: Record<string, any> = {};
            for (const [key, value] of Object.entries(message.headers)) {
              if (value !== undefined) {
                headerObj[key] = value.toString();
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }

const callbackData = UserSignedUpPayloadModule.unmarshal(receivedData);
onDataCallback(undefined, callbackData, extractedHeaders, kafkaMessage);
        }
      });
      resolve(consumer);
    } catch (e: any) {
      reject(e);
    }
  });
}

export { produceToUserSignedup, consumeFromUserSignedup, produceToNoParameter, consumeFromNoParameter };
"
`;

exports[`channels typescript protocol-specific code generation should generate MQTT protocol code with parameters and headers: mqtt-index 1`] = `
"import * as mqtt from './mqtt';

export {mqtt};
"
`;

exports[`channels typescript protocol-specific code generation should generate MQTT protocol code with parameters and headers: mqtt-protocol-code 1`] = `
"import * as TestPayloadModelModule from './../../../../../payloads/TestPayloadModel';
import {TestParameter} from './../../../../../parameters/TestParameter';
import {TestHeaders} from './../../../../../headers/TestHeaders';
import * as Mqtt from 'mqtt';

/**
 * MQTT publish operation for \`user/signedup/{my_parameter}/{enum_parameter}\`
 *
  * @param message to publish
 * @param parameters for topic substitution
 * @param headers optional headers to include with the message as MQTT user properties
 * @param mqtt the MQTT client to publish from
 */
function publishToUserSignedup({
  message, 
  parameters, 
  headers, 
  mqtt
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  parameters: Parameter, 
  headers?: Headers, 
  mqtt: Mqtt.MqttClient
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      // Set up user properties (headers) if provided
      let publishOptions: Mqtt.IClientPublishOptions = {};
      if (headers) {
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        const userProperties: Record<string, string> = {};
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            userProperties[key] = String(value);
          }
        }
        publishOptions.properties = { userProperties };
      }
      mqtt.publish(parameters.getChannelWithParameters('user/signedup/{my_parameter}/{enum_parameter}'), dataToSend, publishOptions);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback subscribeToUserSignedupCallback
 * @param err if any error occurred this will be set
 * @param msg that was received
 * @param parameters that was received in the topic
 * @param headers that was received with the message as MQTT user properties
 * @param mqttMsg the raw MQTT message packet
 */

/**
 * MQTT subscription for \`user/signedup/{my_parameter}/{enum_parameter}\`
 *
 * @param onDataCallback to call when messages are received
 * @param parameters for topic substitution
 * @param mqtt the MQTT client to subscribe with
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToUserSignedup({
  onDataCallback, 
  parameters, 
  mqtt, 
  skipMessageValidation = false
}: {
  onDataCallback: (params: {err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, parameters?: Parameter, headers?: Headers, mqttMsg?: Mqtt.IPublishPacket}) => void, 
  parameters: Parameter, 
  mqtt: Mqtt.MqttClient, 
  skipMessageValidation?: boolean
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      

      // Set up message listener
      const messageHandler = (topic: string, message: Buffer, packet: Mqtt.IPublishPacket) => {
        
    // Check if the received topic matches this subscription's pattern
    const topicPattern = /^user\\/signedup\\/([^.]*)\\/([^.]*)$/;
    if (!topicPattern.test(topic)) {
      return; // Ignore messages not matching this subscription's topic pattern
    }
    
    const receivedData = message.toString();
    const parameters = Parameter.createFromChannel(topic, 'user/signedup/{my_parameter}/{enum_parameter}', /^user\\/signedup\\/([^.]*)\\/([^.]*)$/);
    
    // Extract headers from MQTT v5 user properties
    let extractedHeaders: Headers | undefined;
    if (packet.properties && packet.properties.userProperties) {
      try {
        extractedHeaders = Headers.unmarshal(packet.properties.userProperties);
      } catch (headerError) {
        onDataCallback({err: new Error(\`Failed to parse headers: \${headerError}\`), msg: undefined, parameters, headers: undefined, mqttMsg: packet});
        return;
      }
    }
    
    try {
      const parsedMessage = UserSignedUpPayloadModule.unmarshal(receivedData);
      
      onDataCallback({err: undefined, msg: parsedMessage, parameters, headers: extractedHeaders, mqttMsg: packet});
    } catch (err: any) {
      onDataCallback({err: new Error(\`Failed to parse message: \${err.message}\`), msg: undefined, parameters, headers: extractedHeaders, mqttMsg: packet});
    }
      };

      mqtt.on('message', messageHandler);

      // Subscribe to the topic
      await mqtt.subscribeAsync(parameters.getChannelWithParameters('user/signedup/{my_parameter}/{enum_parameter}'));

      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * MQTT publish operation for \`noparameters\`
 *
  * @param message to publish
 * @param headers optional headers to include with the message as MQTT user properties
 * @param mqtt the MQTT client to publish from
 */
function publishToNoParameter({
  message, 
  headers, 
  mqtt
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  headers?: Headers, 
  mqtt: Mqtt.MqttClient
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      // Set up user properties (headers) if provided
      let publishOptions: Mqtt.IClientPublishOptions = {};
      if (headers) {
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        const userProperties: Record<string, string> = {};
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            userProperties[key] = String(value);
          }
        }
        publishOptions.properties = { userProperties };
      }
      mqtt.publish('noparameters', dataToSend, publishOptions);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback subscribeToNoParameterCallback
 * @param err if any error occurred this will be set
 * @param msg that was received
 * @param headers that was received with the message as MQTT user properties
 * @param mqttMsg the raw MQTT message packet
 */

/**
 * MQTT subscription for \`noparameters\`
 *
 * @param onDataCallback to call when messages are received
 * @param mqtt the MQTT client to subscribe with
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToNoParameter({
  onDataCallback, 
  mqtt, 
  skipMessageValidation = false
}: {
  onDataCallback: (params: {err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, headers?: Headers, mqttMsg?: Mqtt.IPublishPacket}) => void, 
  mqtt: Mqtt.MqttClient, 
  skipMessageValidation?: boolean
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      

      // Set up message listener
      const messageHandler = (topic: string, message: Buffer, packet: Mqtt.IPublishPacket) => {
        
    // Check if the received topic matches this subscription's pattern
    const topicPattern = /^noparameters$/;
    if (!topicPattern.test(topic)) {
      return; // Ignore messages not matching this subscription's topic pattern
    }
    
    const receivedData = message.toString();
    
    
    // Extract headers from MQTT v5 user properties
    let extractedHeaders: Headers | undefined;
    if (packet.properties && packet.properties.userProperties) {
      try {
        extractedHeaders = Headers.unmarshal(packet.properties.userProperties);
      } catch (headerError) {
        onDataCallback({err: new Error(\`Failed to parse headers: \${headerError}\`), msg: undefined, headers: undefined, mqttMsg: packet});
        return;
      }
    }
    
    try {
      const parsedMessage = UserSignedUpPayloadModule.unmarshal(receivedData);
      
      onDataCallback({err: undefined, msg: parsedMessage, headers: extractedHeaders, mqttMsg: packet});
    } catch (err: any) {
      onDataCallback({err: new Error(\`Failed to parse message: \${err.message}\`), msg: undefined, headers: extractedHeaders, mqttMsg: packet});
    }
      };

      mqtt.on('message', messageHandler);

      // Subscribe to the topic
      await mqtt.subscribeAsync('noparameters');

      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

export { publishToUserSignedup, subscribeToUserSignedup, publishToNoParameter, subscribeToNoParameter };
"
`;

exports[`channels typescript protocol-specific code generation should generate NATS protocol code with parameters and headers: nats-index 1`] = `
"import * as nats from './nats';

export {nats};
"
`;

exports[`channels typescript protocol-specific code generation should generate NATS protocol code with parameters and headers: nats-protocol-code 1`] = `
"import * as TestPayloadModelModule from './../../../../../payloads/TestPayloadModel';
import {TestParameter} from './../../../../../parameters/TestParameter';
import {TestHeaders} from './../../../../../headers/TestHeaders';
import * as Nats from 'nats';

/**
 * NATS publish operation for \`user.signedup.{my_parameter}.{enum_parameter}\`
 *
  * @param message to publish
 * @param parameters for topic substitution
 * @param headers optional headers to include with the message
 * @param nc the NATS client to publish from
 * @param codec the serialization codec to use while transmitting the message
 * @param options to use while publishing the message
 */
function publishToUserSignedup({
  message, 
  parameters, 
  headers, 
  nc, 
  codec = Nats.JSONCodec(), 
  options
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  parameters: Parameter, 
  headers?: Headers, 
  nc: Nats.NatsConnection, 
  codec?: Nats.Codec<any>, 
  options?: Nats.PublishOptions
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      // Set up headers if provided
      if (headers) {
        const natsHeaders = Nats.headers();
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            natsHeaders.append(key, String(value));
          }
        }
        options = { ...options, headers: natsHeaders };
      }
dataToSend = codec.encode(dataToSend);
nc.publish(parameters.getChannelWithParameters('user.signedup.{my_parameter}.{enum_parameter}'), dataToSend, options);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback subscribeToUserSignedupCallback
 * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param parameters that was received in the topic
 * @param headers that were received with the message
 * @param natsMsg
 */

/**
 * Core subscription for \`user.signedup.{my_parameter}.{enum_parameter}\`
 *
 * @param {subscribeToUserSignedupCallback} onDataCallback to call when messages are received
 * @param parameters for topic substitution
 * @param nc the nats client to setup the subscribe for
 * @param codec the serialization codec to use while receiving the message
 * @param options when setting up the subscription
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToUserSignedup({
  onDataCallback, 
  parameters, 
  nc, 
  codec = Nats.JSONCodec(), 
  options, 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, parameters?: Parameter, headers?: Headers, natsMsg?: Nats.Msg) => void, 
  parameters: Parameter, 
  nc: Nats.NatsConnection, 
  codec?: Nats.Codec<any>, 
  options?: Nats.SubscriptionOptions, 
  skipMessageValidation?: boolean
}): Promise<Nats.Subscription> {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = nc.subscribe(parameters.getChannelWithParameters('user.signedup.{my_parameter}.{enum_parameter}'), options);
      
      (async () => {
        for await (const msg of subscription) {
          const parameters = Parameter.createFromChannel(msg.subject, 'user.signedup.{my_parameter}.{enum_parameter}', /^user.signedup.([^.]*).([^.]*)$/)
          let receivedData: any = codec.decode(msg.data);
// Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (msg.headers) {
            const headerObj: Record<string, any> = {};
            // NATS headers support both iteration and get() method
            if (typeof msg.headers.keys === 'function') {
              // Use keys() method if available (NATS MsgHdrs)
              for (const key of msg.headers.keys()) {
                headerObj[key] = msg.headers.get(key);
              }
            } else {
              // Fallback to Object.entries for plain objects
              for (const [key, value] of Object.entries(msg.headers)) {
                headerObj[key] = value;
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }
onDataCallback(undefined, UserSignedUpPayloadModule.unmarshal(receivedData), parameters, extractedHeaders, msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPullSubscribeToUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param parameters that was received in the topic
 * @param headers that was received with the message
 * @param jetstreamMsg
 */

/**
 * JetStream pull subscription for \`user.signedup.{my_parameter}.{enum_parameter}\`
 *
  * @param {jetStreamPullSubscribeToUserSignedupCallback} onDataCallback to call when messages are received
 * @param parameters for topic substitution
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while transmitting the message
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function jetStreamPullSubscribeToUserSignedup({
  onDataCallback, 
  parameters, 
  js, 
  options, 
  codec = Nats.JSONCodec(), 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, parameters?: Parameter, headers?: Headers, jetstreamMsg?: Nats.JsMsg) => void, 
  parameters: Parameter, 
  js: Nats.JetStreamClient, 
  options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, 
  codec?: Nats.Codec<any>, 
  skipMessageValidation?: boolean
}): Promise<Nats.JetStreamPullSubscription> {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.pullSubscribe(parameters.getChannelWithParameters('user.signedup.{my_parameter}.{enum_parameter}'), options);
      
      (async () => {
        for await (const msg of subscription) {
          const parameters = Parameter.createFromChannel(msg.subject, 'user.signedup.{my_parameter}.{enum_parameter}', /^user.signedup.([^.]*).([^.]*)$/)
          let receivedData: any = codec.decode(msg.data);
// Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (msg.headers) {
            const headerObj: Record<string, any> = {};
            // NATS headers support both iteration and get() method
            if (typeof msg.headers.keys === 'function') {
              // Use keys() method if available (NATS MsgHdrs)
              for (const key of msg.headers.keys()) {
                headerObj[key] = msg.headers.get(key);
              }
            } else {
              // Fallback to Object.entries for plain objects
              for (const [key, value] of Object.entries(msg.headers)) {
                headerObj[key] = value;
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }
onDataCallback(undefined, UserSignedUpPayloadModule.unmarshal(receivedData), parameters, extractedHeaders, msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPushSubscriptionFromUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param parameters that was received in the topic
 * @param headers that was received with the message
 * @param jetstreamMsg
 */

/**
 * JetStream push subscription for \`user.signedup.{my_parameter}.{enum_parameter}\`
 *
  * @param {jetStreamPushSubscriptionFromUserSignedupCallback} onDataCallback to call when messages are received
 * @param parameters for topic substitution
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while transmitting the message
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function jetStreamPushSubscriptionFromUserSignedup({
  onDataCallback, 
  parameters, 
  js, 
  options, 
  codec = Nats.JSONCodec(), 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, parameters?: Parameter, headers?: Headers, jetstreamMsg?: Nats.JsMsg) => void, 
  parameters: Parameter, 
  js: Nats.JetStreamClient, 
  options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, 
  codec?: Nats.Codec<any>, 
  skipMessageValidation?: boolean
}): Promise<Nats.JetStreamSubscription> {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.subscribe(parameters.getChannelWithParameters('user.signedup.{my_parameter}.{enum_parameter}'), options);
      
      (async () => {
        for await (const msg of subscription) {
          const parameters = Parameter.createFromChannel(msg.subject, 'user.signedup.{my_parameter}.{enum_parameter}', /^user.signedup.([^.]*).([^.]*)$/)
          let receivedData: any = codec.decode(msg.data);
// Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (msg.headers) {
            const headerObj: Record<string, any> = {};
            // NATS headers support both iteration and get() method
            if (typeof msg.headers.keys === 'function') {
              // Use keys() method if available (NATS MsgHdrs)
              for (const key of msg.headers.keys()) {
                headerObj[key] = msg.headers.get(key);
              }
            } else {
              // Fallback to Object.entries for plain objects
              for (const [key, value] of Object.entries(msg.headers)) {
                headerObj[key] = value;
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }
onDataCallback(undefined, UserSignedUpPayloadModule.unmarshal(receivedData), parameters, extractedHeaders, msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * JetStream publish operation for \`user.signedup.{my_parameter}.{enum_parameter}\`
 *
  * @param message to publish over jetstream
 * @param parameters for topic substitution
 * @param headers optional headers to include with the message
 * @param js the JetStream client to publish from
 * @param codec the serialization codec to use while transmitting the message
 * @param options to use while publishing the message
 */
function jetStreamPublishToUserSignedup({
  message, 
  parameters, 
  headers, 
  js, 
  codec = Nats.JSONCodec(), 
  options = {}
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  parameters: Parameter, 
  headers?: Headers, 
  js: Nats.JetStreamClient, 
  codec?: Nats.Codec<any>, 
  options?: Partial<Nats.JetStreamPublishOptions>
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      // Set up headers if provided
      if (headers) {
        const natsHeaders = Nats.headers();
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            natsHeaders.append(key, String(value));
          }
        }
        options = { ...options, headers: natsHeaders };
      }
dataToSend = codec.encode(dataToSend);
await js.publish(parameters.getChannelWithParameters('user.signedup.{my_parameter}.{enum_parameter}'), dataToSend, options);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * NATS publish operation for \`noparameters\`
 *
  * @param message to publish
 * @param headers optional headers to include with the message
 * @param nc the NATS client to publish from
 * @param codec the serialization codec to use while transmitting the message
 * @param options to use while publishing the message
 */
function publishToNoParameter({
  message, 
  headers, 
  nc, 
  codec = Nats.JSONCodec(), 
  options
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  headers?: Headers, 
  nc: Nats.NatsConnection, 
  codec?: Nats.Codec<any>, 
  options?: Nats.PublishOptions
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      // Set up headers if provided
      if (headers) {
        const natsHeaders = Nats.headers();
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            natsHeaders.append(key, String(value));
          }
        }
        options = { ...options, headers: natsHeaders };
      }
dataToSend = codec.encode(dataToSend);
nc.publish('noparameters', dataToSend, options);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback subscribeToNoParameterCallback
 * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param headers that were received with the message
 * @param natsMsg
 */

/**
 * Core subscription for \`noparameters\`
 *
 * @param {subscribeToNoParameterCallback} onDataCallback to call when messages are received
 * @param nc the nats client to setup the subscribe for
 * @param codec the serialization codec to use while receiving the message
 * @param options when setting up the subscription
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToNoParameter({
  onDataCallback, 
  nc, 
  codec = Nats.JSONCodec(), 
  options, 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, headers?: Headers, natsMsg?: Nats.Msg) => void, 
  nc: Nats.NatsConnection, 
  codec?: Nats.Codec<any>, 
  options?: Nats.SubscriptionOptions, 
  skipMessageValidation?: boolean
}): Promise<Nats.Subscription> {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = nc.subscribe('noparameters', options);
      
      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
// Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (msg.headers) {
            const headerObj: Record<string, any> = {};
            // NATS headers support both iteration and get() method
            if (typeof msg.headers.keys === 'function') {
              // Use keys() method if available (NATS MsgHdrs)
              for (const key of msg.headers.keys()) {
                headerObj[key] = msg.headers.get(key);
              }
            } else {
              // Fallback to Object.entries for plain objects
              for (const [key, value] of Object.entries(msg.headers)) {
                headerObj[key] = value;
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }
onDataCallback(undefined, UserSignedUpPayloadModule.unmarshal(receivedData), extractedHeaders, msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPullSubscribeToNoParameterCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param headers that was received with the message
 * @param jetstreamMsg
 */

/**
 * JetStream pull subscription for \`noparameters\`
 *
  * @param {jetStreamPullSubscribeToNoParameterCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while transmitting the message
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function jetStreamPullSubscribeToNoParameter({
  onDataCallback, 
  js, 
  options, 
  codec = Nats.JSONCodec(), 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, headers?: Headers, jetstreamMsg?: Nats.JsMsg) => void, 
  js: Nats.JetStreamClient, 
  options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, 
  codec?: Nats.Codec<any>, 
  skipMessageValidation?: boolean
}): Promise<Nats.JetStreamPullSubscription> {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.pullSubscribe('noparameters', options);
      
      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
// Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (msg.headers) {
            const headerObj: Record<string, any> = {};
            // NATS headers support both iteration and get() method
            if (typeof msg.headers.keys === 'function') {
              // Use keys() method if available (NATS MsgHdrs)
              for (const key of msg.headers.keys()) {
                headerObj[key] = msg.headers.get(key);
              }
            } else {
              // Fallback to Object.entries for plain objects
              for (const [key, value] of Object.entries(msg.headers)) {
                headerObj[key] = value;
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }
onDataCallback(undefined, UserSignedUpPayloadModule.unmarshal(receivedData), extractedHeaders, msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPushSubscriptionFromNoParameterCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param headers that was received with the message
 * @param jetstreamMsg
 */

/**
 * JetStream push subscription for \`noparameters\`
 *
  * @param {jetStreamPushSubscriptionFromNoParameterCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while transmitting the message
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function jetStreamPushSubscriptionFromNoParameter({
  onDataCallback, 
  js, 
  options, 
  codec = Nats.JSONCodec(), 
  skipMessageValidation = false
}: {
  onDataCallback: (err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, headers?: Headers, jetstreamMsg?: Nats.JsMsg) => void, 
  js: Nats.JetStreamClient, 
  options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, 
  codec?: Nats.Codec<any>, 
  skipMessageValidation?: boolean
}): Promise<Nats.JetStreamSubscription> {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.subscribe('noparameters', options);
      
      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
// Extract headers if present
          let extractedHeaders: Headers | undefined = undefined;
          if (msg.headers) {
            const headerObj: Record<string, any> = {};
            // NATS headers support both iteration and get() method
            if (typeof msg.headers.keys === 'function') {
              // Use keys() method if available (NATS MsgHdrs)
              for (const key of msg.headers.keys()) {
                headerObj[key] = msg.headers.get(key);
              }
            } else {
              // Fallback to Object.entries for plain objects
              for (const [key, value] of Object.entries(msg.headers)) {
                headerObj[key] = value;
              }
            }
            extractedHeaders = Headers.unmarshal(headerObj);
          }
onDataCallback(undefined, UserSignedUpPayloadModule.unmarshal(receivedData), extractedHeaders, msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}

/**
 * JetStream publish operation for \`noparameters\`
 *
  * @param message to publish over jetstream
 * @param headers optional headers to include with the message
 * @param js the JetStream client to publish from
 * @param codec the serialization codec to use while transmitting the message
 * @param options to use while publishing the message
 */
function jetStreamPublishToNoParameter({
  message, 
  headers, 
  js, 
  codec = Nats.JSONCodec(), 
  options = {}
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload, 
  headers?: Headers, 
  js: Nats.JetStreamClient, 
  codec?: Nats.Codec<any>, 
  options?: Partial<Nats.JetStreamPublishOptions>
}): Promise<void> {
  return new Promise<void>(async (resolve, reject) => {
    try {
      let dataToSend: any = UserSignedUpPayloadModule.marshal(message);
      // Set up headers if provided
      if (headers) {
        const natsHeaders = Nats.headers();
        const headerData = headers.marshal();
        const parsedHeaders = typeof headerData === 'string' ? JSON.parse(headerData) : headerData;
        for (const [key, value] of Object.entries(parsedHeaders)) {
          if (value !== undefined) {
            natsHeaders.append(key, String(value));
          }
        }
        options = { ...options, headers: natsHeaders };
      }
dataToSend = codec.encode(dataToSend);
await js.publish('noparameters', dataToSend, options);
      resolve();
    } catch (e: any) {
      reject(e);
    }
  });
}

export { publishToUserSignedup, subscribeToUserSignedup, jetStreamPullSubscribeToUserSignedup, jetStreamPushSubscriptionFromUserSignedup, jetStreamPublishToUserSignedup, publishToNoParameter, subscribeToNoParameter, jetStreamPullSubscribeToNoParameter, jetStreamPushSubscriptionFromNoParameter, jetStreamPublishToNoParameter };
"
`;

exports[`channels typescript protocol-specific code generation should generate WebSocket protocol code with parameters and headers: websocket-index 1`] = `
"import * as websocket from './websocket';

export {websocket};
"
`;

exports[`channels typescript protocol-specific code generation should generate WebSocket protocol code with parameters and headers: websocket-protocol-code 1`] = `
"import * as TestPayloadModelModule from './../../../../../payloads/TestPayloadModel';
import {TestParameter} from './../../../../../parameters/TestParameter';
import {TestHeaders} from './../../../../../headers/TestHeaders';
import * as WebSocket from 'ws';
import { IncomingMessage } from 'http';

/**
 * WebSocket client-side function to publish messages to \`/user/signedup/{my_parameter}/{enum_parameter}\`
 *
 * @param message to publish
 * @param ws the WebSocket connection (assumed to be already connected)
 */
function publishToUserSignedup({
  message,
  ws
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload,
  ws: WebSocket.WebSocket
}): Promise<void> {
  return new Promise((resolve, reject) => {
    // Check if WebSocket is open
    if (ws.readyState !== WebSocket.WebSocket.OPEN) {
      reject(new Error('WebSocket is not open'));
      return;
    }

    // Send message directly
    ws.send(UserSignedUpPayloadModule.marshal(message), (err) => {
      if (err) {
        reject(new Error(\`Failed to send message: \${err.message}\`));
      }
      resolve();
    });
  });
}

/**
 * WebSocket client-side function to subscribe to messages from \`/user/signedup/{my_parameter}/{enum_parameter}\`
 *
 * @param onDataCallback callback when messages are received
 * @param parameters for URL path substitution
 * @param ws the WebSocket connection (assumed to be already connected)
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToUserSignedup({
  onDataCallback,
  parameters,
  ws,
  skipMessageValidation = false
}: {
  onDataCallback: (params: {err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, parameters?: Parameter, ws?: WebSocket.WebSocket}) => void,
  parameters: Parameter,
  ws: WebSocket.WebSocket,
  skipMessageValidation?: boolean
}): void {
  try {
    // Check if WebSocket is open
    if (ws.readyState !== WebSocket.WebSocket.OPEN) {
      onDataCallback({
        err: new Error('WebSocket is not open'),
        msg: undefined,
        parameters,
        ws
      });
      return;
    }

    const validator = UserSignedUpPayloadModule.createValidator();

    ws.on('message', (data: WebSocket.RawData) => {
      try {
        const receivedData = data.toString();
        const parsedMessage = UserSignedUpPayloadModule.unmarshal(receivedData);
        
        // Validate message if validation is enabled
        if (!skipMessageValidation) {
          const messageToValidate = UserSignedUpPayloadModule.marshal(parsedMessage);
          const {valid, errors} = UserSignedUpPayloadModule.validate({data: messageToValidate, ajvValidatorFunction: validator});
          if (!valid) {
            onDataCallback({
              err: new Error(\`Invalid message payload received; \${JSON.stringify({cause: errors})}\`),
              msg: undefined,
              parameters,
              ws
            });
            return;
          }
        }

        onDataCallback({
          err: undefined,
          msg: parsedMessage,
          parameters,
          ws
        });

      } catch (error: any) {
        onDataCallback({
          err: new Error(\`Failed to parse message: \${error.message}\`),
          msg: undefined,
          parameters,
          ws
        });
      }
    });

    ws.on('error', (error: Error) => {
      onDataCallback({
        err: new Error(\`WebSocket error: \${error.message}\`),
        msg: undefined,
        parameters,
        ws
      });
    });

    ws.on('close', (code: number, reason: Buffer) => {
      // Only report as error if it's not a normal closure (1000) or going away (1001)
      if (code !== 1000 && code !== 1001 && code !== 1005) { // 1005 is no status received
        onDataCallback({
          err: new Error(\`WebSocket closed unexpectedly: \${code} \${reason.toString()}\`),
          msg: undefined,
          parameters,
          ws
        });
      }
    });

  } catch (error: any) {
    onDataCallback({
      err: new Error(\`Failed to set up WebSocket subscription: \${error.message}\`),
      msg: undefined,
      parameters,
      ws
    });
  }
}

/**
 * WebSocket server-side function to handle messages for \`/user/signedup/{my_parameter}/{enum_parameter}\`
 *
 * @param wss the WebSocket server instance
 * @param onConnection callback when a client connects to this channel
 * @param onMessage callback when a message is received on this channel
 */
function registerUserSignedup({
  wss,
  onConnection,
  onMessage
}: {
  wss: WebSocket.WebSocketServer,
  onConnection: (params: {parameters: Parameter, ws: WebSocket.WebSocket, request: IncomingMessage}) => void,
  onMessage: (params: {message: UserSignedUpPayloadModule.UserSignedUpPayload, ws: WebSocket.WebSocket}) => void
}): void {
  const channelPattern = /^\\/user\\/signedup\\/([^\\\\/]*)\\/([^\\\\/]*)(?:\\?.*)?$/;
  
  wss.on('connection', (ws: WebSocket.WebSocket, request: IncomingMessage) => {
    try {
      const url = request.url || '';
      const match = url.match(channelPattern);
      if (match) {
        try {
          const channelPath = url.startsWith('/') ? url.slice(1) : url;
              const parameters = Parameter.createFromChannel(channelPath, 'user/signedup/{my_parameter}/{enum_parameter}', /^user\\/signedup\\/([^\\\\/]*)\\/([^\\\\/]*)$/);
          onConnection({
            parameters,
            ws,
            request
          });
        } catch (connectionError) {
          console.error('Error in onConnection callback:', connectionError);
          ws.close(1011, 'Connection error');
          return;
        }
        
        ws.on('message', (data: WebSocket.RawData) => {
          try {
            const receivedData = data.toString();
            const parsedMessage = UserSignedUpPayloadModule.unmarshal(receivedData);
            onMessage({
              message: parsedMessage,
              ws
            });
          } catch (error: any) {
            // Ignore parsing errors
          }
        });
      }
    } catch (error: any) {
      ws.close(1011, 'Server error');
    }
  });
}

/**
 * WebSocket client-side function to publish messages to \`/noparameters\`
 *
 * @param message to publish
 * @param ws the WebSocket connection (assumed to be already connected)
 */
function publishToNoParameter({
  message,
  ws
}: {
  message: UserSignedUpPayloadModule.UserSignedUpPayload,
  ws: WebSocket.WebSocket
}): Promise<void> {
  return new Promise((resolve, reject) => {
    // Check if WebSocket is open
    if (ws.readyState !== WebSocket.WebSocket.OPEN) {
      reject(new Error('WebSocket is not open'));
      return;
    }

    // Send message directly
    ws.send(UserSignedUpPayloadModule.marshal(message), (err) => {
      if (err) {
        reject(new Error(\`Failed to send message: \${err.message}\`));
      }
      resolve();
    });
  });
}

/**
 * WebSocket client-side function to subscribe to messages from \`/noparameters\`
 *
 * @param onDataCallback callback when messages are received
 * @param ws the WebSocket connection (assumed to be already connected)
 * @param skipMessageValidation turn off runtime validation of incoming messages
 */
function subscribeToNoParameter({
  onDataCallback,
  ws,
  skipMessageValidation = false
}: {
  onDataCallback: (params: {err?: Error, msg?: UserSignedUpPayloadModule.UserSignedUpPayload, ws?: WebSocket.WebSocket}) => void,
  ws: WebSocket.WebSocket,
  skipMessageValidation?: boolean
}): void {
  try {
    // Check if WebSocket is open
    if (ws.readyState !== WebSocket.WebSocket.OPEN) {
      onDataCallback({
        err: new Error('WebSocket is not open'),
        msg: undefined,
        ws
      });
      return;
    }

    const validator = UserSignedUpPayloadModule.createValidator();

    ws.on('message', (data: WebSocket.RawData) => {
      try {
        const receivedData = data.toString();
        const parsedMessage = UserSignedUpPayloadModule.unmarshal(receivedData);
        
        // Validate message if validation is enabled
        if (!skipMessageValidation) {
          const messageToValidate = UserSignedUpPayloadModule.marshal(parsedMessage);
          const {valid, errors} = UserSignedUpPayloadModule.validate({data: messageToValidate, ajvValidatorFunction: validator});
          if (!valid) {
            onDataCallback({
              err: new Error(\`Invalid message payload received; \${JSON.stringify({cause: errors})}\`),
              msg: undefined,
              ws
            });
            return;
          }
        }

        onDataCallback({
          err: undefined,
          msg: parsedMessage,
          ws
        });

      } catch (error: any) {
        onDataCallback({
          err: new Error(\`Failed to parse message: \${error.message}\`),
          msg: undefined,
          ws
        });
      }
    });

    ws.on('error', (error: Error) => {
      onDataCallback({
        err: new Error(\`WebSocket error: \${error.message}\`),
        msg: undefined,
        ws
      });
    });

    ws.on('close', (code: number, reason: Buffer) => {
      // Only report as error if it's not a normal closure (1000) or going away (1001)
      if (code !== 1000 && code !== 1001 && code !== 1005) { // 1005 is no status received
        onDataCallback({
          err: new Error(\`WebSocket closed unexpectedly: \${code} \${reason.toString()}\`),
          msg: undefined,
          ws
        });
      }
    });

  } catch (error: any) {
    onDataCallback({
      err: new Error(\`Failed to set up WebSocket subscription: \${error.message}\`),
      msg: undefined,
      ws
    });
  }
}

/**
 * WebSocket server-side function to handle messages for \`/noparameters\`
 *
 * @param wss the WebSocket server instance
 * @param onConnection callback when a client connects to this channel
 * @param onMessage callback when a message is received on this channel
 */
function registerNoParameter({
  wss,
  onConnection,
  onMessage
}: {
  wss: WebSocket.WebSocketServer,
  onConnection: (params: {ws: WebSocket.WebSocket, request: IncomingMessage}) => void,
  onMessage: (params: {message: UserSignedUpPayloadModule.UserSignedUpPayload, ws: WebSocket.WebSocket}) => void
}): void {
  const channelPattern = /^\\/noparameters(?:\\?.*)?$/;
  
  wss.on('connection', (ws: WebSocket.WebSocket, request: IncomingMessage) => {
    try {
      const url = request.url || '';
      const match = url.match(channelPattern);
      if (match) {
        try {
          
          onConnection({
            ws,
            request
          });
        } catch (connectionError) {
          console.error('Error in onConnection callback:', connectionError);
          ws.close(1011, 'Connection error');
          return;
        }
        
        ws.on('message', (data: WebSocket.RawData) => {
          try {
            const receivedData = data.toString();
            const parsedMessage = UserSignedUpPayloadModule.unmarshal(receivedData);
            onMessage({
              message: parsedMessage,
              ws
            });
          } catch (error: any) {
            // Ignore parsing errors
          }
        });
      }
    } catch (error: any) {
      ws.close(1011, 'Server error');
    }
  });
}

export { publishToUserSignedup, subscribeToUserSignedup, registerUserSignedup, publishToNoParameter, subscribeToNoParameter, registerNoParameter };
"
`;

exports[`channels typescript should work with basic AsyncAPI inputs 1`] = `
"import * as nats from './nats';
import * as amqp from './amqp';
import * as mqtt from './mqtt';
import * as kafka from './kafka';
import * as event_source from './event_source';

export {nats, amqp, mqtt, kafka, event_source};
"
`;

exports[`channels typescript should work with basic AsyncAPI inputs with no parameters 1`] = `
"import * as nats from './nats';
import * as amqp from './amqp';
import * as mqtt from './mqtt';
import * as kafka from './kafka';
import * as event_source from './event_source';

export {nats, amqp, mqtt, kafka, event_source};
"
`;

exports[`channels typescript should work with operation extension 1`] = `
"import * as nats from './nats';

export {nats};
"
`;

exports[`channels typescript should work with request and reply AsyncAPI 1`] = `
"import * as http_client from './http_client';

export {http_client};
"
`;
