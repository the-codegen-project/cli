// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`channels typescript should work with basic AsyncAPI inputs 1`] = `
"import * as TestPayloadModelModule from './../../../../TestPayloadModel';
import {TestParameter} from './../../../../TestParameter';
import * as Nats from 'nats';
export const Protocols = {
nats: {
  /**
 * Callback for when receiving messages
 *
 * @callback subscribeToUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param natsMsg
 */

/**
 * Core subscription for \`user.signedup\`
 * 
  * @param {subscribeToUserSignedupCallback} onDataCallback to call when messages are received
 * @param nc the NATS client to subscribe through
 * @param codec the serialization codec to use while receiving the message
 * @param options when setting up the subscription
 */
subscribeToUserSignedup: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, natsMsg?: Nats.Msg) => void, nc: Nats.NatsConnection, codec: any = Nats.JSONCodec(), options?: Nats.SubscriptionOptions
): Promise<Nats.Subscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = nc.subscribe('user.signedup', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
},
/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPullSubscribeToUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param jetstreamMsg
 */

/**
 * JetStream pull subscription for \`user.signedup\`
 * 
  * @param {jetStreamPullSubscribeToUserSignedupCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while receiving the message
 */
jetStreamPullSubscribeToUserSignedup: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, jetstreamMsg?: Nats.JsMsg) => void, js: Nats.JetStreamClient, options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, codec: any = Nats.JSONCodec()
): Promise<Nats.JetStreamPullSubscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.pullSubscribe('user.signedup', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
},
/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPushSubscriptionFromUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param jetstreamMsg
 */

/**
 * JetStream push subscription for \`user.signedup\`
 * 
  * @param {jetStreamPushSubscriptionFromUserSignedupCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while receiving the message
 */
jetStreamPushSubscriptionFromUserSignedup: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, jetstreamMsg?: Nats.JsMsg) => void, js: Nats.JetStreamClient, options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, codec: any = Nats.JSONCodec()
): Promise<Nats.JetStreamSubscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.subscribe('user.signedup', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}
}};"
`;

exports[`channels typescript should work with basic AsyncAPI inputs with no parameters 1`] = `
"import * as TestPayloadModelModule from './../../../../TestPayloadModel';
import * as Nats from 'nats';
export const Protocols = {
nats: {
  /**
 * Callback for when receiving messages
 *
 * @callback subscribeToUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param natsMsg
 */

/**
 * Core subscription for \`user.signedup\`
 * 
  * @param {subscribeToUserSignedupCallback} onDataCallback to call when messages are received
 * @param nc the NATS client to subscribe through
 * @param codec the serialization codec to use while receiving the message
 * @param options when setting up the subscription
 */
subscribeToUserSignedup: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, natsMsg?: Nats.Msg) => void, nc: Nats.NatsConnection, codec: any = Nats.JSONCodec(), options?: Nats.SubscriptionOptions
): Promise<Nats.Subscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = nc.subscribe('user.signedup', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
},
/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPullSubscribeToUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param jetstreamMsg
 */

/**
 * JetStream pull subscription for \`user.signedup\`
 * 
  * @param {jetStreamPullSubscribeToUserSignedupCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while receiving the message
 */
jetStreamPullSubscribeToUserSignedup: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, jetstreamMsg?: Nats.JsMsg) => void, js: Nats.JetStreamClient, options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, codec: any = Nats.JSONCodec()
): Promise<Nats.JetStreamPullSubscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.pullSubscribe('user.signedup', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
},
/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPushSubscriptionFromUserSignedupCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param jetstreamMsg
 */

/**
 * JetStream push subscription for \`user.signedup\`
 * 
  * @param {jetStreamPushSubscriptionFromUserSignedupCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while receiving the message
 */
jetStreamPushSubscriptionFromUserSignedup: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, jetstreamMsg?: Nats.JsMsg) => void, js: Nats.JetStreamClient, options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, codec: any = Nats.JSONCodec()
): Promise<Nats.JetStreamSubscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.subscribe('user.signedup', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}
}};"
`;

exports[`channels typescript should work with request and reply AsyncAPI 1`] = `
"import * as TestPayloadModelModule from './../../../../TestPayloadModel';
import * as Nats from 'nats';
export const Protocols = {
nats: {
  /**
 * Callback for when receiving messages
 *
 * @callback subscribeToPingCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param natsMsg
 */

/**
 * Core subscription for \`ping\`
 * 
  * @param {subscribeToPingCallback} onDataCallback to call when messages are received
 * @param nc the NATS client to subscribe through
 * @param codec the serialization codec to use while receiving the message
 * @param options when setting up the subscription
 */
subscribeToPing: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, natsMsg?: Nats.Msg) => void, nc: Nats.NatsConnection, codec: any = Nats.JSONCodec(), options?: Nats.SubscriptionOptions
): Promise<Nats.Subscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = nc.subscribe('ping', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
},
/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPullSubscribeToPingCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param jetstreamMsg
 */

/**
 * JetStream pull subscription for \`ping\`
 * 
  * @param {jetStreamPullSubscribeToPingCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while receiving the message
 */
jetStreamPullSubscribeToPing: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, jetstreamMsg?: Nats.JsMsg) => void, js: Nats.JetStreamClient, options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, codec: any = Nats.JSONCodec()
): Promise<Nats.JetStreamPullSubscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.pullSubscribe('ping', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
},
/**
 * Callback for when receiving messages
 *
 * @callback jetStreamPushSubscriptionFromPingCallback
  * @param err if any error occurred this will be sat
 * @param msg that was received
 * @param jetstreamMsg
 */

/**
 * JetStream push subscription for \`ping\`
 * 
  * @param {jetStreamPushSubscriptionFromPingCallback} onDataCallback to call when messages are received
 * @param js the JetStream client to pull subscribe through
 * @param options when setting up the subscription
 * @param codec the serialization codec to use while receiving the message
 */
jetStreamPushSubscriptionFromPing: (
  onDataCallback: (err?: Error, msg?: MessageTypeModule.MessageType, jetstreamMsg?: Nats.JsMsg) => void, js: Nats.JetStreamClient, options: Nats.ConsumerOptsBuilder | Partial<Nats.ConsumerOpts>, codec: any = Nats.JSONCodec()
): Promise<Nats.JetStreamSubscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      const subscription = await js.subscribe('ping', options);

      (async () => {
        for await (const msg of subscription) {
          
          let receivedData: any = codec.decode(msg.data);
onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData), msg);
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
},
/**
 * Callback for when receiving the request
 *
 * @callback replyToPingCallback
  * @param err if any error occurred this will be sat
 * @param requestMessage that was received from the request
 */

/**
 * Reply for \`ping\`
 * 
  * @param {replyToPingCallback} onDataCallback to call when the request is received
 * @param nc the nats client to setup the reply for
 * @param codec the serialization codec to use when receiving and transmitting reply
 * @param options when setting up the reply
 */
replyToPing: (
  onDataCallback: (err?: Error, requestMessage?: MessageTypeModule.MessageType) => MessageTypeModule | Promise<MessageTypeModule>, 
  nc: Nats.NatsConnection, 
  codec: any = Nats.JSONCodec(), 
  options?: Nats.SubscriptionOptions
): Promise<Nats.Subscription> => {
  return new Promise(async (resolve, reject) => {
    try {
      let subscription = nc.subscribe('ping', options);
      (async () => {
        for await (const msg of subscription) {
          

          let receivedData : any = codec.decode(msg.data);
const replyMessage = await onDataCallback(undefined, MessageTypeModule.unmarshal(receivedData) );

          if (msg.reply) {
            let dataToSend : any = replyMessage.marshal();
dataToSend = codec.encode(dataToSend);
msg.respond(dataToSend);
          } else {
            onDataCallback(new Error('Expected request to need a reply, did not..'))
          }
        }
      })();
      resolve(subscription);
    } catch (e: any) {
      reject(e);
    }
  });
}
}};"
`;
